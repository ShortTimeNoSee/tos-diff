This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
scraper/
  .env
  package.json
  scraper.js
  system_prompt.txt
service-config/
  google.json
web/
  src/
    lib/
      services.js
    routes/
      services/
        [service]/
          +page.svelte
      +layout.css
      +layout.svelte
      +page.svelte
    app.html
    hooks.server.js
  package.json
  svelte.config.js
  tsconfig.json
  vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="scraper/.env">
XAI_API_KEY=xai-37RtF5CFM6f2MTUqCMupIJYusR2X8IeXEsmzKOydjQosR2IIgQH8ffnCoi4D1kS5UOrzxQbSPYZJIgxM
DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/1393484544921042955/mx97cfQ-LWe5NTJgRR0g6OJKTEZEdUzm_fl62VqEjDm_nu2C4Z3LcJY4SfIFnO35TtX7
</file>

<file path="scraper/package.json">
{
  "name": "tos-scraper",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node scraper.js"
  },
  "dependencies": {
    "diff": "^5.1.0",
    "dotenv": "^16.0.0",
    "formdata-node": "^6.0.3",
    "openai": "^5.9.0",
    "puppeteer": "^22.8.2",
    "sanitize-html": "^2.8.1"
  }
}
</file>

<file path="scraper/scraper.js">
import fs from 'fs/promises';
import path from 'path';
import puppeteer from 'puppeteer';
import sanitizeHtml from 'sanitize-html';
import { diffLines } from 'diff';
import OpenAI from 'openai';
import dotenv from 'dotenv';
dotenv.config();

const xai = new OpenAI({
  apiKey: process.env.XAI_API_KEY,
  baseURL: 'https://api.x.ai/v1'
});

const FAILURES_LOG = 'scraper/failures.log';
const AI_RETRIES = 3;

async function alertAdmin(details) {
  const webhookUrl = process.env.DISCORD_WEBHOOK_URL;
  const message = `
**Admin Alert**
**Service:** ${details.service}
**Document:** ${details.docType}
---
**Raw AI Response:**
\`\`\`
${details.rawResponse}
\`\`\`
  `;

  if (webhookUrl) {
    try {
      await fetch(webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: message }),
      });
      console.log(`Admin alert sent for ${details.service} ${details.docType}`);
    } catch (error) {
      console.error('Failed to send Discord alert:', error.message);
      const logMessage = `${new Date().toISOString()} - DISCORD_ALERT_FAILED: ${JSON.stringify(details)}\n`;
      await fs.appendFile(FAILURES_LOG, logMessage);
    }
  } else {
    console.warn(`Admin alert triggered for ${details.service} ${details.docType}, but no DISCORD_WEBHOOK_URL is set. Logging to failures.log.`);
    const logMessage = `${new Date().toISOString()} - ADMIN_ALERT: ${JSON.stringify(details)}\n`;
    await fs.appendFile(FAILURES_LOG, logMessage);
  }
}

// Helper function to split text into sentences
function splitIntoSentences(text) {
  // Remove HTML tags and normalize whitespace
  const cleanText = text.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
  // Split on sentence endings followed by whitespace
  return cleanText.split(/(?<=[.?!])\s+/).filter(sentence => sentence.trim().length > 0);
}

// Helper function to parse HTML into sections with headings
function parseIntoSections(html) {
  const sections = [];
  const lines = html.split('\n');
  let currentSection = null;
  let currentContent = [];
  
  for (const line of lines) {
    // Check for heading tags
    const headingMatch = line.match(/<h([1-6])[^>]*>(.*?)<\/h[1-6]>/i);
    if (headingMatch) {
      // Save previous section if exists
      if (currentSection) {
        sections.push({
          title: currentSection.title,
          content: currentContent.join('\n').trim(),
          level: currentSection.level
        });
      }
      
      // Start new section
      currentSection = {
        title: headingMatch[2].replace(/<[^>]*>/g, '').trim(),
        level: parseInt(headingMatch[1])
      };
      currentContent = [];
    } else if (currentSection) {
      currentContent.push(line);
    }
  }
  
  // Add the last section
  if (currentSection) {
    sections.push({
      title: currentSection.title,
      content: currentContent.join('\n').trim(),
      level: currentSection.level
    });
  }
  
  return sections;
}

// Helper function to find which section contains a given sentence
function findSectionForSentence(sentence, sections) {
  for (const section of sections) {
    if (section.content.includes(sentence)) {
      return section;
    }
  }
  return null;
}

// Helper function to create contextual diff with surrounding content
function createContextualDiff(oldText, newText) {
  const oldSentences = splitIntoSentences(oldText);
  const newSentences = splitIntoSentences(newText);
  const newSections = parseIntoSections(newText);
  
  const result = [];
  let i = 0, j = 0;
  
  while (i < oldSentences.length || j < newSentences.length) {
    if (i < oldSentences.length && j < newSentences.length && oldSentences[i] === newSentences[j]) {
      // Sentences match, keep unchanged
      result.push({ type: 'unchanged', value: oldSentences[i] });
      i++;
      j++;
    } else if (j < newSentences.length && (i >= oldSentences.length || !oldSentences.includes(newSentences[j]))) {
      // New sentence added
      const section = findSectionForSentence(newSentences[j], newSections);
      result.push({ 
        type: 'added', 
        value: newSentences[j],
        context: section ? section.title : null
      });
      j++;
    } else if (i < oldSentences.length && (j >= newSentences.length || !newSentences.includes(oldSentences[i]))) {
      // Old sentence removed
      result.push({ type: 'removed', value: oldSentences[i] });
      i++;
    } else {
      // Handle case where sentences are similar but not identical
      const section = findSectionForSentence(newSentences[j], newSections);
      result.push({ type: 'removed', value: oldSentences[i] });
      result.push({ 
        type: 'added', 
        value: newSentences[j],
        context: section ? section.title : null
      });
      i++;
      j++;
    }
  }
  
  return result;
}

// Helper function to create sentence-based diff (legacy, for backward compatibility)
function diffSentences(oldText, newText) {
  const oldSentences = splitIntoSentences(oldText);
  const newSentences = splitIntoSentences(newText);
  
  const result = [];
  let i = 0, j = 0;
  
  while (i < oldSentences.length || j < newSentences.length) {
    if (i < oldSentences.length && j < newSentences.length && oldSentences[i] === newSentences[j]) {
      // Sentences match, keep unchanged
      result.push({ type: 'unchanged', value: oldSentences[i] });
      i++;
      j++;
    } else if (j < newSentences.length && (i >= oldSentences.length || !oldSentences.includes(newSentences[j]))) {
      // New sentence added
      result.push({ type: 'added', value: newSentences[j] });
      j++;
    } else if (i < oldSentences.length && (j >= newSentences.length || !newSentences.includes(oldSentences[i]))) {
      // Old sentence removed
      result.push({ type: 'removed', value: oldSentences[i] });
      i++;
    } else {
      // Handle case where sentences are similar but not identical
      result.push({ type: 'removed', value: oldSentences[i] });
      result.push({ type: 'added', value: newSentences[j] });
      i++;
      j++;
    }
  }
  
  return result;
}

function getRandomDelay() {
  return Math.floor(Math.random() * 6000) + 2000;
}

async function scrapeDocument(page, cfg, docType, url, selector, systemPrompt) {
  try {
    console.log(`Scraping ${cfg.service} ${docType}...`);
    
    try {
      await page.goto(url, { waitUntil: 'networkidle0', timeout: 30000 });
    } catch (error) {
      console.warn(`Failed to navigate to ${url} for ${cfg.service} ${docType}:`, error.message);
      return;
    }

    let raw;
    try {
      raw = await page.$eval(selector, el => el.innerHTML);
    } catch (error) {
      console.warn(`Selector "${selector}" not found for ${cfg.service} ${docType}:`, error.message);
      return;
    }

    const clean = sanitizeHtml(raw, {
      allowedTags: sanitizeHtml.defaults.allowedTags.concat(['h1','h2','h3','h4','h5','h6'])
    });

    const storage = path.join('scraper/storage', cfg.service, docType);
    await fs.mkdir(storage, { recursive: true });
    const prevFile = path.join(storage, 'prev.html');
    let prev = '';
    try { prev = await fs.readFile(prevFile, 'utf-8'); } catch {}
    if (prev === clean) {
      console.log(`No changes detected for ${cfg.service} ${docType}`);
      return;
    }

    await fs.writeFile(prevFile, clean);
    
    // Use contextual diffing to provide better context to AI
    const contextualDiff = createContextualDiff(prev, clean);
    
    // Build contextual prompt with section information
    const contextualChanges = contextualDiff
      .filter(p => p.type === 'added' || p.type === 'removed')
      .map(p => {
        const prefix = p.type === 'added' ? '+' : '-';
        const context = p.context ? ` [Section: ${p.context}]` : '';
        return `${prefix}${p.value}${context}`;
      });
    
    const diffText = contextualChanges.join('\n');
    
    // Create simple diff for HTML display (without context)
    const simpleDiff = contextualDiff.map(p => 
      (p.type === 'added' ? '+' : p.type === 'removed' ? '-' : '') + p.value
    ).join('\n');

    const diffHtml = contextualDiff.map(p => {
      const esc = p.value
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;');
      if (p.type === 'added') return `<div class="added">${esc}</div>`;
      if (p.type === 'removed') return `<div class="removed">${esc}</div>`;
      return `<div>${esc}</div>`;
    }).join('');

    const prompt = `Summarize these ${docType} changes as a Markdown bullet list. Each change includes the section context where it occurred:\n\n${diffText}`;
    
    let completion;
    let lastError = null;

    for (let i = 0; i < AI_RETRIES; i++) {
      try {
        completion = await xai.chat.completions.create({
          model: 'grok-3-mini',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: prompt }
          ],
          reasoning_effort: 'high'
        });
        lastError = null; // Clear error on success
        break; // Exit loop on success
      } catch (error) {
        lastError = error;
        console.warn(`AI completion failed for ${cfg.service} ${docType} (attempt ${i + 1}/${AI_RETRIES}):`, error.message);
        if (i < AI_RETRIES - 1) {
          await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s before retry
        }
      }
    }

    if (lastError) {
      const logMessage = `${new Date().toISOString()} - SERVICE: ${cfg.service}, TYPE: ${docType}, ERROR: ${lastError.message}\n`;
      await fs.appendFile(FAILURES_LOG, logMessage);
      
      console.warn(`AI summary failed for ${cfg.service} ${docType} after ${AI_RETRIES} attempts. Logged to ${FAILURES_LOG}.`);
      const outDir = path.join('web/static/data', cfg.service.toLowerCase(), docType);
      await fs.mkdir(outDir, { recursive: true });
      const changesFile = path.join(outDir, 'changes.json');
      
      let data = { schemaVersion: 1, changes: [] };
      try {
        const fileContent = await fs.readFile(changesFile, 'utf-8');
        const existingData = JSON.parse(fileContent);
        if (Array.isArray(existingData)) {
          data.changes = existingData;
        } else {
          data = existingData;
        }
      } catch {}
      
      data.changes.unshift({
        timestamp: new Date().toISOString(),
        type: docType,
        summary: ['<p>Changes detected but AI summary failed</p>'],
        diffHtml
      });
      await fs.writeFile(changesFile, JSON.stringify(data, null, 2));
      return; // End execution for this document
    }
    
    const aiResponse = completion.choices[0].message.content;

    if (aiResponse.includes('alert_admin()')) {
      await alertAdmin({
        service: cfg.service,
        docType: docType,
        rawResponse: aiResponse
      });
    }

    const summaryLines = aiResponse
      .replace(/alert_admin\(\)/g, '') // Remove the function call from the output
      .trim()
      .split(/\r?\n/)
      .filter(Boolean)
      .map(l => `<p>${l}</p>`);

    const outDir = path.join('web/static/data', cfg.service.toLowerCase(), docType);
    await fs.mkdir(outDir, { recursive: true });
    const changesFile = path.join(outDir, 'changes.json');

    let data = { schemaVersion: 1, changes: [] };
    try {
      const fileContent = await fs.readFile(changesFile, 'utf-8');
      const existingData = JSON.parse(fileContent);
      if (Array.isArray(existingData)) {
        data.changes = existingData; // Convert old format
      } else if (existingData && typeof existingData === 'object') {
        data = existingData;
      }
    } catch {}

    data.changes.unshift({
      timestamp: new Date().toISOString(),
      type: docType,
      summary: summaryLines,
      diffHtml
    });
    await fs.writeFile(changesFile, JSON.stringify(data, null, 2));
    
    console.log(`Changes detected and processed for ${cfg.service} ${docType}`);

  } catch (error) {
    console.error(`Unexpected error processing ${cfg.service} ${docType}:`, error.message);
  }
}

async function scrapeService(page, cfg, systemPrompt) {
  // Scrape Terms of Service
  if (cfg.tos_url && cfg.tos_selector) {
    await scrapeDocument(page, cfg, 'tos', cfg.tos_url, cfg.tos_selector, systemPrompt);
  }
  
  // Scrape Privacy Policy
  if (cfg.privacy_url && cfg.privacy_selector) {
    await scrapeDocument(page, cfg, 'privacy', cfg.privacy_url, cfg.privacy_selector, systemPrompt);
  }
}

async function main() {
  const systemPrompt = await fs.readFile('scraper/system_prompt.txt', 'utf-8');
  let browser;
  try {
    console.log('Launching browser...');
    browser = await puppeteer.launch({ args: ['--no-sandbox'] });
    
    const cfgDir = path.resolve('service-config');
    const files = await fs.readdir(cfgDir);
    
    for (const f of files) {
      if (!f.endsWith('.json')) continue;
      
      const cfg = JSON.parse(await fs.readFile(path.join(cfgDir, f), 'utf-8'));
      
      const page = await browser.newPage();
      try {
        await scrapeService(page, cfg, systemPrompt);
      } finally {
        await page.close();
      }
      
      if (files.indexOf(f) < files.length - 1) {
        const delay = getRandomDelay();
        console.log(`Waiting ${delay/1000}s before next scrape...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  } catch (error) {
    console.error('Error in main:', error);
  } finally {
    if (browser) {
      console.log('Closing browser...');
      await browser.close();
    }
  }
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
</file>

<file path="scraper/system_prompt.txt">
You are a legal-change assistant. When you receive HTML diffs of Terms of Service or Privacy Policy changes, summarize them as a Markdown bullet list. For each change, follow these rules:

1. Start each bullet with one or more type tags in square brackets, with no spaces inside the brackets.
   - If there's a single applicable category, use `[Category]`.
   - If multiple apply, list them comma-separated within the same brackets, e.g. `[Data Sharing, Consent Requirement]`.
2. After the closing bracket(s), put a space, then a concise description of the change in plain English.
3. Use exactly these categories (case-sensitive):
   - New Obligation
   - Privacy Impact
   - Data Sharing
   - Tracking Change
   - Consent Requirement
   - Permission Grant
   - Security Update
   - Payment Terms
   - Termination Clause
   - Retention Policy
   - Third-Party Integration
   - Age Restriction
   - Service Modification
   - Typo Fix
   - Formatting Change
   - Clarification
4. If a change does not clearly match any category, use `[Clarification]`.
5. Do not include any other text outside the bullet list. Example output:
   - [Data Sharing] Third-party analytics provider X added to Section 4.
   - [Typo Fix] Corrected "privact" to "privacy" in subsection 2.
6. If you detect any of the following, call `alert_admin()` instead of—or in addition to—your summary:
   - A major clause addition or removal with broad legal or privacy impact
   - Malformed, empty, or unexpectedly truncated diff content
   - Uncertainty about the real-world implications or nuanced legal context
   - Any change exceeding 200 words or containing unusual formatting
</file>

<file path="service-config/google.json">
{
  "service": "Google",
  "tos_url": "https://policies.google.com/terms",
  "privacy_url": "https://policies.google.com/privacy",
  "tos_selector": "#main-content",
  "privacy_selector": "#main-content",
  "aliases": ["Google", "Alphabet"]
}
</file>

<file path="web/src/lib/services.js">
export default ['google'];
</file>

<file path="web/src/routes/services/[service]/+page.svelte">
<script context="module">
  export async function load({ params, fetch }) {
    const svc = params.service.toLowerCase();
    
    const [tosRes, privacyRes] = await Promise.allSettled([
      fetch(`/data/${svc}/tos/changes.json`),
      fetch(`/data/${svc}/privacy/changes.json`)
    ]);
    
    let tosChanges = [];
    if (tosRes.status === 'fulfilled' && tosRes.value.ok) {
      const data = await tosRes.value.json();
      tosChanges = Array.isArray(data) ? data : data.changes || [];
    }
    
    let privacyChanges = [];
    if (privacyRes.status === 'fulfilled' && privacyRes.value.ok) {
      const data = await privacyRes.value.json();
      privacyChanges = Array.isArray(data) ? data : data.changes || [];
    }
    
    if (tosChanges.length === 0 && privacyChanges.length === 0) {
      const legacyRes = await fetch(`/data/${svc}/changes.json`);
      if (legacyRes.ok) {
        const legacyData = await legacyRes.json();
        const legacyChanges = Array.isArray(legacyData) ? legacyData : legacyData.changes || [];
        return { 
          props: { 
            service: params.service, 
            tosChanges: legacyChanges,
            privacyChanges: [],
            activeTab: 'tos'
          } 
        };
      }
    }
    
    return { 
      props: { 
        service: params.service, 
        tosChanges,
        privacyChanges,
        activeTab: 'tos'
      } 
    };
  }
</script>

<script>
  export let service;
  export let tosChanges;
  export let privacyChanges;
  export let activeTab;
  
  function setActiveTab(tab) {
    activeTab = tab;
  }
</script>

<h1>{service} Legal Document Changes</h1>

<div class="tabs">
  <button 
    class:active={activeTab === 'tos'} 
    on:click={() => setActiveTab('tos')}
  >
    Terms of Service ({tosChanges.length})
  </button>
  <button 
    class:active={activeTab === 'privacy'} 
    on:click={() => setActiveTab('privacy')}
  >
    Privacy Policy ({privacyChanges.length})
  </button>
</div>

{#if activeTab === 'tos'}
  <div class="content">
    {#if tosChanges.length === 0}
      <p>No Terms of Service changes detected yet.</p>
    {:else}
      {#each tosChanges as change}
        <section>
          <h2>{new Date(change.timestamp).toLocaleString()}</h2>
          <div class="summary">
            {@html change.summary.join('')}
          </div>
          <details>
            <summary>View full diff</summary>
            <div class="diff">
              {@html change.diffHtml}
            </div>
          </details>
        </section>
      {/each}
    {/if}
  </div>
{:else}
  <div class="content">
    {#if privacyChanges.length === 0}
      <p>No Privacy Policy changes detected yet.</p>
    {:else}
      {#each privacyChanges as change}
        <section>
          <h2>{new Date(change.timestamp).toLocaleString()}</h2>
          <div class="summary">
            {@html change.summary.join('')}
          </div>
          <details>
            <summary>View full diff</summary>
            <div class="diff">
              {@html change.diffHtml}
            </div>
          </details>
        </section>
      {/each}
    {/if}
  </div>
{/if}

<style>
  .tabs {
    display: flex;
    gap: 1rem;
    margin-bottom: 2rem;
  }
  
  .tabs button {
    padding: 0.5rem 1rem;
    border: 1px solid #ccc;
    background: #f5f5f5;
    cursor: pointer;
    border-radius: 4px;
  }
  
  .tabs button.active {
    background: #007bff;
    color: white;
    border-color: #007bff;
  }
  
  .content {
    margin-top: 1rem;
  }
  
  section {
    margin-bottom: 2rem;
    padding: 1rem;
    border: 1px solid #ddd;
    border-radius: 4px;
  }
  
  .summary {
    margin: 1rem 0;
  }
  
  .diff {
    margin-top: 1rem;
    padding: 1rem;
    background: #f8f9fa;
    border-radius: 4px;
    font-family: monospace;
    white-space: pre-wrap;
  }
  
  .added {
    background: #d4edda;
    color: #155724;
  }
  
  .removed {
    background: #f8d7da;
    color: #721c24;
  }
</style>
</file>

<file path="web/src/routes/+layout.css">
.added {
  background-color: #e6ffed;
}
.removed {
  background-color: #ffeef0;
}
body {
  font-family: system-ui, sans-serif;
  margin: 2rem;
}
nav a {
  text-decoration: none;
  font-weight: bold;
}
</file>

<file path="web/src/routes/+layout.svelte">
<script>
  export let data;
</script>

<nav>
  <a href="/">Home</a>
</nav>

<slot />
</file>

<file path="web/src/routes/+page.svelte">
<script>
  import services from '$lib/services.js';
</script>

<h1>Terms of Service Tracker</h1>
<ul>
  {#each services as svc}
    <li><a href={`/services/${svc}`}>{svc}</a></li>
  {/each}
</ul>
</file>

<file path="web/src/app.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.png" />
    <meta name="viewport" content="width=device-width" />
    %sveltekit.head%
  </head>
  <body>
    %sveltekit.body%
  </body>
</html>
</file>

<file path="web/src/hooks.server.js">
export const handle = async ({ event, resolve }) => {
  const response = await resolve(event);
  response.headers.set(
    'Content-Security-Policy',
    "default-src 'self'; style-src 'self';"
  );
  response.headers.set(
    'Strict-Transport-Security',
    'max-age=31536000; includeSubDomains'
  );
  return response;
};
</file>

<file path="web/package.json">
{
  "name": "tos-diff-web",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite dev",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@sveltejs/kit": "^2.22.5",
    "svelte": "^5.0.0"
  },
  "devDependencies": {
    "@sveltejs/adapter-static": "^3.0.8",
    "@types/estree": "^1.0.8",
    "svelte-preprocess": "^6.0.3"
  },
  "overrides": {
    "cookie": "0.7.1"
  }
}
</file>

<file path="web/svelte.config.js">
import adapter from '@sveltejs/adapter-static';
import preprocess from 'svelte-preprocess';

export default {
  preprocess: preprocess(),
  kit: {
    // tell adapter-static to emit a SPA fallback "200.html"
    // and not error out on dynamic routes
    adapter: adapter({
      pages: 'build',
      assets: 'build',
      fallback: '200.html',
      strict: false
    })
  }
};
</file>

<file path="web/tsconfig.json">
{
  "extends": "./.svelte-kit/tsconfig.json",
  "compilerOptions": {
    "strict": true,
    "skipLibCheck": true,
    "types": []
  }
}
</file>

<file path="web/vite.config.js">
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [sveltekit()]
});
</file>

</files>
