This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    scraper.yml
scraper/
  .env
  package.json
  scraper.js
  system_prompt.txt
service-config/
  google.json
  sidebysearch.json
web/
  src/
    routes/
      api/
        services/
          [service]/
            +server.js
          +server.js
      disclaimer/
        +page.svelte
      services/
        [service]/
          +page.js
          +page.svelte
      +layout.css
      +layout.svelte
      +page.js
      +page.svelte
    app.html
    hooks.server.js
  package.json
  svelte.config.js
  tsconfig.json
  vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="scraper/.env">
XAI_API_KEY=xai-37RtF5CFM6f2MTUqCMupIJYusR2X8IeXEsmzKOydjQosR2IIgQH8ffnCoi4D1kS5UOrzxQbSPYZJIgxM
DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/1393484544921042955/mx97cfQ-LWe5NTJgRR0g6OJKTEZEdUzm_fl62VqEjDm_nu2C4Z3LcJY4SfIFnO35TtX7
</file>

<file path="scraper/package.json">
{
  "name": "tos-scraper",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node scraper.js"
  },
  "dependencies": {
    "diff": "^5.1.0",
    "dotenv": "^16.0.0",
    "formdata-node": "^6.0.3",
    "openai": "^5.9.0",
    "puppeteer": "^22.8.2",
    "sanitize-html": "^2.8.1"
  }
}
</file>

<file path="service-config/google.json">
{
  "service": "Google",
  "documents": {
    "Terms of Service": {
      "url": "https://policies.google.com/terms",
      "selector": "#main-content"
    },
    "Privacy Policy": {
      "url": "https://policies.google.com/privacy",
      "selector": "#main-content"
    }
  },
  "aliases": ["Google", "Alphabet"]
}
</file>

<file path="service-config/sidebysearch.json">
{
  "service": "SideBySearch",
  "documents": {
    "Privacy Policy": {
      "url": "https://sidebysearch.org/privacy",
      "selector": "main"
    }
  }
}
</file>

<file path="web/src/routes/api/services/+server.js">
import fs from 'fs/promises';
import path from 'path';

export async function GET() {
  try {
    const configDir = path.resolve('../service-config');
    const files = await fs.readdir(configDir);

    const services = await Promise.all(files
      .filter(file => file.endsWith('.json'))
      .map(async (file) => {
        const filePath = path.join(configDir, file);
        const fileContent = await fs.readFile(filePath, 'utf-8');
        const config = JSON.parse(fileContent);
        return {
          id: file.replace('.json', ''),
          name: config.service
        };
      })
    );

    return new Response(JSON.stringify(services), {
      headers: { 'Content-Type': 'application/json' },
      status: 200
    });

  } catch (error) {
    console.error('Failed to list services:', error);
    return new Response(JSON.stringify({ error: 'Could not load services' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
</file>

<file path="web/src/routes/disclaimer/+page.svelte">
<h1>Disclaimer</h1>

<p><strong>No Affiliation:</strong> This website is an independent project and is not affiliated with, endorsed by, or in any way officially connected with any of the companies whose terms of service or privacy policies are displayed here. All company names, logos, and trademarks are the property of their respective owners.</p>

<p><strong>For Informational Purposes Only:</strong> The content provided on this website is for informational purposes only. It is automatically scraped from public sources and is presented without any alteration or manual review. The goal is to provide a convenient way to track changes to these legal documents over time.</p>

<p><strong>No Legal Advice:</strong> The information on this site does not constitute, and should not be relied upon as, legal advice. We make no representations or warranties of any kind, express or implied, about the completeness, accuracy, reliability, suitability, or availability of the information contained on the website.</p>

<p><strong>Verify Information:</strong> We strongly encourage all users to review the official terms of service and privacy policies directly on the respective companies' websites before making any decisions based on the information presented here. Your legal rights and obligations are determined by the original documents.</p>

<p><strong>Limitation of Liability:</strong> In no event will we be liable for any loss or damage including without limitation, indirect or consequential loss or damage, or any loss or damage whatsoever arising from loss of data or profits arising out of, or in connection with, the use of this website.</p>

<style>
  h1 {
    margin-bottom: 2rem;
  }
  p {
    margin-bottom: 1rem;
    line-height: 1.6;
    max-width: 80ch;
  }
  p strong {
    color: var(--text-primary);
    font-weight: 700;
  }
</style>
</file>

<file path="web/src/routes/+page.js">
export async function load({ fetch }) {
  try {
    const res = await fetch('/api/services');
    if (!res.ok) {
      console.error('Failed to fetch services list');
      return { services: [] };
    }
    const services = await res.json();
    return { services };
  } catch (error) {
    console.error('Error loading services:', error);
    return { services: [] };
  }
}
</file>

<file path="web/src/app.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.png" />
    <meta name="viewport" content="width=device-width" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    %sveltekit.head%
  </head>
  <body>
    <div style="display: contents">
      %sveltekit.body%
    </div>
  </body>
</html>
</file>

<file path="web/package.json">
{
  "name": "tos-diff-web",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite dev",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@sveltejs/kit": "^2.22.5",
    "svelte": "^5.0.0"
  },
  "devDependencies": {
    "@sveltejs/adapter-static": "^3.0.8",
    "@types/estree": "^1.0.8",
    "svelte-preprocess": "^6.0.3"
  },
  "overrides": {
    "cookie": "0.7.1"
  }
}
</file>

<file path="web/tsconfig.json">
{
  "extends": "./.svelte-kit/tsconfig.json",
  "compilerOptions": {
    "strict": true,
    "skipLibCheck": true,
    "types": []
  }
}
</file>

<file path="web/vite.config.js">
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [sveltekit()]
});
</file>

<file path=".github/workflows/scraper.yml">
name: Automated Document Scraper

on:
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch: # Allow manual triggering

jobs:
  scrape:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: Install dependencies
      run: |
        cd scraper
        npm install
        
    - name: Run scraper
      env:
        # These secrets are configured in GitHub repository settings
        XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        node scraper/scraper.js
        
    - name: Check for changes
      id: check_changes
      run: |
        if [ -n "$(git status --porcelain)" ]; then
          echo "has_changes=true" >> $GITHUB_OUTPUT
        else
          echo "has_changes=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Commit and push changes
      if: steps.check_changes.outputs.has_changes == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        git commit -m "Auto-update: Document changes detected $(date)"
        git push
</file>

<file path="scraper/scraper.js">
import fs from 'fs/promises';
import path from 'path';
import { createHash } from 'crypto';
import puppeteer from 'puppeteer';
import sanitizeHtml from 'sanitize-html';
import { diffLines } from 'diff';
import OpenAI from 'openai';
import dotenv from 'dotenv';

const scriptDirForEnv = path.dirname(import.meta.url.substring(7));
dotenv.config({ path: path.resolve(scriptDirForEnv, '.env') });

const xai = new OpenAI({
  apiKey: process.env.XAI_API_KEY,
  baseURL: 'https://api.x.ai/v1'
});

const FAILURES_LOG = 'scraper/failures.log';
const AI_RETRIES = 3;

async function alertAdmin(details) {
  const webhookUrl = process.env.DISCORD_WEBHOOK_URL;
  const message = `
**Admin Alert**
**Service:** ${details.service}
**Document:** ${details.docType}
---
**Raw AI Response:**
\`\`\`
${details.rawResponse}
\`\`\`
  `;

  if (webhookUrl) {
    try {
      await fetch(webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: message }),
      });
      console.log(`Admin alert sent for ${details.service} ${details.docType}`);
    } catch (error) {
      console.error('Failed to send Discord alert:', error.message);
      const logMessage = `${new Date().toISOString()} - DISCORD_ALERT_FAILED: ${JSON.stringify(details)}\n`;
      await fs.appendFile(FAILURES_LOG, logMessage);
    }
  } else {
    console.warn(`Admin alert triggered for ${details.service} ${details.docType}, but no DISCORD_WEBHOOK_URL is set. Logging to failures.log.`);
    const logMessage = `${new Date().toISOString()} - ADMIN_ALERT: ${JSON.stringify(details)}\n`;
    await fs.appendFile(FAILURES_LOG, logMessage);
  }
}

function getRandomDelay() {
  return Math.floor(Math.random() * 6000) + 2000;
}

async function scrapeDocument(page, cfg, docType, docSlug, url, selector, systemPrompt) {
  try {
    console.log(`Scraping ${cfg.service} ${docType}...`);
    
    try {
      await page.goto(url, { waitUntil: 'networkidle0', timeout: 30000 });
    } catch (error) {
      console.warn(`Failed to navigate to ${url} for ${cfg.service} ${docType}:`, error.message);
      return;
    }

    let raw;
    try {
      raw = await page.$eval(selector, el => el.innerHTML);
    } catch (error) {
      console.warn(`Selector "${selector}" not found for ${cfg.service} ${docType}:`, error.message);
      return;
    }

    const sourceHash = createHash('sha256').update(raw).digest('hex');

    const clean = sanitizeHtml(raw, {
      allowedTags: [
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'a', 'b', 'i', 'strong', 'em', 'ul', 'ol', 'li', 'blockquote', 'pre', 'code', 'br', 'hr', 'table', 'thead', 'tbody', 'tr', 'th', 'td'
      ],
      allowedAttributes: {
        'a': ['href', 'target', 'rel']
      }
    });

    const storage = path.resolve(scriptDirForEnv, 'storage', cfg.service, docSlug);
    await fs.mkdir(storage, { recursive: true });
    const prevFile = path.join(storage, 'prev.html');
    let prev = '';
    let isFirstRun = false;
    try {
      prev = await fs.readFile(prevFile, 'utf-8');
    } catch {
      isFirstRun = true;
    }

    if (prev === clean) {
      console.log(`No changes detected for ${cfg.service} ${docType}`);
      return;
    }

    if (isFirstRun) {
      await fs.writeFile(prevFile, clean);
      console.log(`Initial content saved for ${cfg.service} ${docType}. No diff generated on first run.`);
      return;
    }

    await fs.writeFile(prevFile, clean);
    
    const diff = diffLines(prev, clean);

    const significantDiff = diff.filter(part => {
        return part.added || part.removed || part.value.trim().length > 0;
    });

    if (!significantDiff.some(part => part.added || part.removed)) {
        console.log(`No significant changes detected (whitespace only) for ${cfg.service} ${docType}`);
        return;
    }
    
    const diffText = significantDiff
      .filter(p => p.added || p.removed)
      .map(p => {
        const prefix = p.added ? '+' : '-';
        return p.value.split(/\r?\n/).map(line => `${prefix} ${line}`).join('\n');
      })
      .join('');
    
    const diffHtml = significantDiff.map(part => {
      const className = part.added ? 'added' : part.removed ? 'removed' : '';
      const escapedValue = part.value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      if (className) {
        return `<div class="${className}">${escapedValue}</div>`;
      }
      return `<div>${escapedValue}</div>`;
    }).join('');

    const prompt = `Summarize these ${docType} changes as a Markdown bullet list. The changes are provided in a diff format, with lines prefixed by '+' for additions and '-' for removals. The diff contains HTML, so interpret it accordingly:\n\n${diffText}`;
    
    let completion;
    let lastError = null;

    for (let i = 0; i < AI_RETRIES; i++) {
      try {
        completion = await xai.chat.completions.create({
          model: 'grok-3-mini',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: prompt }
          ],
          reasoning_effort: 'high'
        });
        lastError = null;
        break;
      } catch (error) {
        lastError = error;
        console.warn(`AI completion failed for ${cfg.service} ${docType} (attempt ${i + 1}/${AI_RETRIES}):`, error.message);
        if (i < AI_RETRIES - 1) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }
    }

    if (lastError) {
      const logMessage = `${new Date().toISOString()} - SERVICE: ${cfg.service}, TYPE: ${docType}, ERROR: ${lastError.message}\n`;
      await fs.appendFile(FAILURES_LOG, logMessage);
      
      console.warn(`AI summary failed for ${cfg.service} ${docType} after ${AI_RETRIES} attempts. Logged to ${FAILURES_LOG}.`);
      const outDir = path.resolve(scriptDirForEnv, '../web/static/data', cfg.service.toLowerCase(), docSlug);
      await fs.mkdir(outDir, { recursive: true });
      const changesFile = path.join(outDir, 'changes.json');
      
      let data = { schemaVersion: 2, changes: [] };
      try {
        const fileContent = await fs.readFile(changesFile, 'utf-8');
        const existingData = JSON.parse(fileContent);
        if (Array.isArray(existingData)) {
          data.changes = existingData;
        } else {
          data = existingData;
        }
      } catch {}
      
      data.changes.unshift({
        timestamp: new Date().toISOString(),
        type: docType,
        summary: ['<p>Changes detected but AI summary failed</p>'],
        diffHtml
      });
      await fs.writeFile(changesFile, JSON.stringify(data, null, 2));
      return;
    }
    
    const aiResponse = completion.choices[0].message.content;

    if (aiResponse.includes('alert_admin()')) {
      await alertAdmin({
        service: cfg.service,
        docType: docType,
        rawResponse: aiResponse
      });
    }

    const summaryLines = aiResponse
      .replace(/alert_admin\(\)/g, '')
      .trim()
      .split(/\r?\n/)
      .filter(line => Boolean(line) && !line.includes('[ADMIN]'))
      .map(l => `<p>${l}</p>`);

    const outDir = path.resolve(scriptDirForEnv, '../web/static/data', cfg.service.toLowerCase(), docSlug);
    await fs.mkdir(outDir, { recursive: true });
    const changesFile = path.join(outDir, 'changes.json');

    let data = { schemaVersion: 2, changes: [] };
    try {
      const fileContent = await fs.readFile(changesFile, 'utf-8');
      const existingData = JSON.parse(fileContent);
      if (Array.isArray(existingData)) {
        data.changes = existingData;
      } else if (existingData && typeof existingData === 'object') {
        data = existingData;
      }
    } catch {}

    const timestamp = new Date().toISOString();
    const sourceHtmlFile = `${new Date(timestamp).getTime()}-source.html`;
    await fs.writeFile(path.join(outDir, sourceHtmlFile), raw);

    data.changes.unshift({
      timestamp: timestamp,
      type: docType,
      summary: summaryLines,
      diffHtml,
      sourceHash,
      sourceHtmlFile
    });
    await fs.writeFile(changesFile, JSON.stringify(data, null, 2));
    
    console.log(`Changes detected and processed for ${cfg.service} ${docType}`);

  } catch (error) {
    console.error(`Unexpected error processing ${cfg.service} ${docType}:`, error.message);
  }
}

async function scrapeService(page, cfg, systemPrompt) {
  if (!cfg.documents) return;

  const docTypes = Object.keys(cfg.documents);
  for (let i = 0; i < docTypes.length; i++) {
    const docType = docTypes[i];
    const docConfig = cfg.documents[docType];
    if (docConfig.url && docConfig.selector) {
      const docSlug = docType.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
      await scrapeDocument(page, cfg, docType, docSlug, docConfig.url, docConfig.selector, systemPrompt);
    }
    
    if (i < docTypes.length - 1) {
      const delay = getRandomDelay();
      console.log(`Waiting ${delay / 1000}s before next scrape...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

async function main() {
  const scriptDir = path.dirname(import.meta.url.substring(7));
  const systemPromptPath = path.resolve(scriptDir, 'system_prompt.txt');
  const systemPrompt = await fs.readFile(systemPromptPath, 'utf-8');
  
  await fs.mkdir('web/static/data', { recursive: true });
  
  let browser;
  try {
    console.log('Launching browser...');
    browser = await puppeteer.launch({ args: ['--no-sandbox'] });
    
    const cfgDir = path.resolve(scriptDir, '../service-config');
    const files = await fs.readdir(cfgDir);
    
    for (const f of files) {
      if (!f.endsWith('.json')) continue;
      
      const cfg = JSON.parse(await fs.readFile(path.join(cfgDir, f), 'utf-8'));
      
      const page = await browser.newPage();
      try {
        await scrapeService(page, cfg, systemPrompt);
      } finally {
        await page.close();
      }
    }
  } catch (error) {
    console.error('Error in main:', error);
  } finally {
    if (browser) {
      console.log('Closing browser...');
      await browser.close();
    }
  }
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
</file>

<file path="scraper/system_prompt.txt">
When you receive diffs of Legal Document changes, summarize them as a Markdown bullets

1. Start each bullet with 1+ type tags in square brackets.
   - If there's a single applicable category, use `[Category]`.
   - If multiple apply, list them comma-separated within the same brackets, `[Data Sharing, Consent Requirement]`.
2. After the closing bracket, put a concise description of the change in plain English.
3. Use these categories (case-sensitive):
   - New Obligation
   - Privacy Impact
   - Data Sharing
   - Tracking Change
   - Consent Requirement
   - Permission Grant
   - Security Update
   - Payment Terms
   - Termination Clause
   - Retention Policy
   - Third-Party Integration
   - Age Restriction
   - Service Modification
   - Typo Fix
   - Formatting Change
   - Clarification
4. If a change does not clearly match any category, use `[Clarification]`.
5. Do not include any other text outside the bullet list. Example output:
   - [Data Sharing] Third-party analytics provider X added to Section 4.
   - [Typo Fix] Corrected "privact" to "privacy" in subsection 2.
6. If a change has severe implications that require immediate human review, add a special bullet point at the end of your summary: `- [ADMIN] alert_admin()`. This should be reserved for critical issues.
7. Use the `[ADMIN]` tag for truly significant changes ONLY, such as new clauses that dramatically alter user rights, enable widespread data sharing with third parties without clear user consent, or introduce significant new legal liabilities. Do not use it for minor clarifications, cookie policy adjustments (unless they represent a fundamental shift in tracking), or routine updates.
</file>

<file path="web/src/routes/api/services/[service]/+server.js">
import fs from 'fs/promises';
import path from 'path';

export async function GET({ params }) {
  try {
    const serviceName = params.service.toLowerCase();
    
    const configPath = path.resolve('../service-config', `${serviceName}.json`);
    
    const fileContent = await fs.readFile(configPath, 'utf-8');
    const config = JSON.parse(fileContent);
    
    const documents = Object.keys(config.documents || {});
    
    return new Response(JSON.stringify({
      serviceName: config.service,
      documents
    }), {
      headers: { 'Content-Type': 'application/json' },
      status: 200
    });

  } catch (error) {
    return new Response(JSON.stringify({ error: 'Service not found' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
</file>

<file path="web/src/routes/services/[service]/+page.js">
export async function load({ params, fetch }) {
  try {
    const svc = params.service.toLowerCase();

    const docsRes = await fetch(`/api/services/${svc}`);
    if (!docsRes.ok) {
      return { service: params.service, documents: {}, activeTab: null };
    }
    const { serviceName, documents: docNames } = await docsRes.json();

    const slugify = (text) => text.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
    const promises = docNames.map(docName =>
      fetch(`/data/${svc}/${slugify(docName)}/changes.json`)
    );
    const results = await Promise.allSettled(promises);

    const documents = {};
    for (let i = 0; i < docNames.length; i++) {
      const docName = docNames[i];
      const res = results[i];
      let changes = [];
      if (res.status === 'fulfilled' && res.value.ok) {
        const data = await res.value.json();
        changes = data.changes || (Array.isArray(data) ? data : []);
      }
      documents[docName] = { changes };
    }

    return {
      service: serviceName,
      documents,
      activeTab: docNames.length > 0 ? docNames[0] : null
    };

  } catch (error) {
    console.error("Failed to load service changes:", error);
    return {
      service: params.service,
      documents: {},
      activeTab: null
    };
  }
}
</file>

<file path="web/src/routes/services/[service]/+page.svelte">
<script>
  export let data;

  let activeTab = data.activeTab;

  function setActiveTab(tab) {
    activeTab = tab;
  }

  async function copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      alert('Hash copied to clipboard!');
    } catch (err) {
      console.error('Failed to copy text: ', err);
    }
  }
</script>

<h1>{data.service} Legal Document Changes</h1>

{#if data.documents && Object.keys(data.documents).length > 0}
  <div class="tabs">
    {#each Object.keys(data.documents) as docName}
      <button
        class:active={activeTab === docName}
        on:click={() => setActiveTab(docName)}
        disabled={data.documents[docName].changes.length === 0}
      >
        {docName} ({data.documents[docName].changes.length})
      </button>
    {/each}
  </div>

  {#if activeTab && data.documents[activeTab]}
    {@const currentDoc = data.documents[activeTab]}
    <div class="content">
      {#if currentDoc.changes.length === 0}
        <p>No {activeTab} changes detected yet.</p>
      {:else}
        {#each currentDoc.changes as change}
          <section>
            <div class="change-meta">
              <h2>{new Date(change.timestamp).toLocaleString()}</h2>
              <div class="meta-controls">
                {#if change.sourceHtmlFile}
                  <a href="/data/{data.service.toLowerCase()}/{activeTab.toLowerCase().replace(/\s+/g, '-')}/{change.sourceHtmlFile}" target="_blank" class="source-link">
                    View Source
                  </a>
                {/if}
                {#if change.sourceHash}
                  <button
                    type="button"
                    class="source-hash"
                    title="Click to copy full hash: {change.sourceHash}"
                    on:click={() => copyToClipboard(change.sourceHash)}
                  >
                    Source Hash: {change.sourceHash.substring(0, 12)}...
                  </button>
                {/if}
              </div>
            </div>
            <div class="summary">
              {@html change.summary.join('')}
            </div>
            <details>
              <summary>View full diff</summary>
              <div class="diff">
                {@html change.diffHtml}
              </div>
            </details>
          </section>
        {/each}
      {/if}
    </div>
  {/if}
{:else}
  <p>No documents are configured for this service yet.</p>
{/if}

<style>
  h1 {
    text-transform: none;
  }
  .tabs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 2rem;
    border-bottom: 1px solid var(--border);
  }

  .tabs button {
    padding: 0.75rem 1.25rem;
    border: none;
    background: transparent;
    cursor: pointer;
    border-radius: 6px 6px 0 0;
    font-size: 1rem;
    color: var(--text-secondary);
    position: relative;
    top: 1px;
    transition: background-color 0.2s ease, color 0.2s ease;
  }

  .tabs button:disabled {
    color: var(--text-secondary);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tabs button.active {
    background: var(--background);
    color: var(--primary);
    border-bottom: 2px solid var(--primary);
  }

  .tabs button:not(.active):not(:disabled):hover {
    background-color: var(--surface);
    color: var(--text-primary);
  }

  .content {
    margin-top: 1rem;
  }

  section {
    margin-bottom: 2rem;
    padding: 1.5rem;
    border: 1px solid var(--border);
    border-radius: 8px;
    background-color: var(--surface);
  }

  .change-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
  }

  .meta-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  section h2 {
    font-size: 1rem;
    font-weight: normal;
    color: var(--text-secondary);
    margin: 0;
  }

  .source-link {
    font-size: 0.8em;
    color: var(--text-secondary);
    text-decoration: none;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    transition: background-color 0.2s;
  }

  .source-link:hover {
    background-color: var(--border);
    text-decoration: underline;
  }

  .source-hash {
    font-family: 'Roboto Mono', monospace;
    font-size: 0.8em;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    transition: background-color 0.2s;
    background: none;
    border: none;
    text-align: left;
  }

  .source-hash:hover {
    background-color: var(--border);
  }

  .summary {
    margin: 1rem 0;
  }

  .summary :global(p) {
    margin: 0.5rem 0;
  }

  details {
    margin-top: 1.5rem;
  }

  details summary {
    cursor: pointer;
    font-weight: bold;
    color: var(--text-secondary);
  }

  details summary:hover {
    color: var(--primary);
  }

  .diff {
    margin-top: 1rem;
    padding: 1rem;
    background: var(--background);
    border-radius: 4px;
    font-family: 'Roboto Mono', monospace;
    white-space: pre-wrap;
    font-size: 0.9em;
    border: 1px solid var(--border);
  }
</style>
</file>

<file path="web/src/routes/+layout.css">
:root {
  --background: #112;
  --surface: #223;
  --primary: #48f;
  --on-primary: #fff;
  --text-primary: #eee;
  --text-secondary: #ccc;
  --border: #334;
  --added-bg: #4ba1;
  --removed-bg: #f431;
  --added-color: #48f;
  --removed-color: #f44;
}

.added {
  background-color: var(--added-bg);
  color: var(--added-color);
}
.removed {
  background-color: var(--removed-bg);
  color: var(--removed-color);
}

body {
  font-family: 'Inter', sans-serif;
  margin: 0;
  padding: 0;
  background-color: var(--background);
  color: var(--text-primary);
  line-height: 1.6;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1.5rem 2rem;
  border-bottom: 1px solid var(--border);
}

.logo {
  font-weight: 700;
  font-size: 1.2rem;
  text-decoration: none;
  color: var(--text-primary);
}

main {
  padding: 2rem;
}

nav {
  display: flex;
  gap: 1.5rem;
  padding-bottom: 2rem;
  border-bottom: 1px solid var(--border);
  margin-bottom: 2rem;
}

nav a {
  text-decoration: none;
  font-weight: bold;
  color: var(--text-secondary);
  transition: color 0.2s ease-in-out;
}

nav a:hover {
  color: var(--primary);
}

h1, h2, h3 {
  color: var(--text-primary);
  font-weight: 700;
}

a {
  color: var(--primary);
}
</file>

<file path="web/src/routes/+layout.svelte">
<script>
  import './+layout.css';
</script>

<header>
  <a href="/" class="logo">Legal Document Changes</a>
  <nav>
    <a href="/disclaimer">Disclaimer</a>
  </nav>
</header>

<main>
  <slot />
</main>
</file>

<file path="web/src/routes/+page.svelte">
<script>
  export let data;

  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
</script>

<div class="hero">
  <h1>Track Legal Document Changes</h1>
  <p>An automated watchdog for Terms of Service and Privacy Policy updates from major tech companies.</p>
</div>

<div class="service-grid">
  {#each data.services as service}
    <a href={`/services/${service.id}`} class="service-card">
      <h3>{service.name}</h3>
    </a>
  {/each}
</div>

<style>
  .hero {
    text-align: center;
    margin-bottom: 4rem;
  }

  .hero h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
  }

  .hero p {
    font-size: 1.1rem;
    color: var(--text-secondary);
    max-width: 60ch;
    margin: 0 auto;
  }

  .service-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 1.5rem;
  }

  .service-card {
    background-color: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 2rem;
    text-align: center;
    text-decoration: none;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  .service-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
  }

  .service-card h3 {
    margin: 0;
    font-size: 1.5rem;
    color: var(--text-primary);
  }
</style>
</file>

<file path="web/src/hooks.server.js">
import { dev } from '$app/environment';

export const handle = async ({ event, resolve }) => {
  const response = await resolve(event);

  if (!event.isSubRequest) {
    const csp = [
      "default-src 'self'",
      `script-src 'self' ${dev ? "'unsafe-inline'" : ''}`,
      `style-src 'self' https://fonts.googleapis.com ${dev ? "'unsafe-inline'" : ''}`,
      "font-src 'self' https://fonts.gstatic.com",
      `connect-src 'self' ${dev ? 'ws:' : ''}`,
    ]
      .join('; ')
      .trim();

    response.headers.set('Content-Security-Policy', csp);
    response.headers.set(
      'Strict-Transport-Security',
      'max-age=31536000; includeSubDomains'
    );
  }

  return response;
};
</file>

<file path="web/svelte.config.js">
import adapter from '@sveltejs/adapter-static';
import preprocess from 'svelte-preprocess';

export default {
  preprocess: preprocess(),
  kit: {
    adapter: adapter({
      pages: 'build',
      assets: 'build',
      fallback: '200.html',
      strict: false
    })
  }
};
</file>

</files>
