<directory_structure>
.github/
  workflows/
    scraper.yml
scraper/
  .env
  package.json
  README.md
  scraper.js
  system_prompt.txt
service-config/
  duckduckgo.json
  facebook.json
  google.json
  instagram.json
  meta.json
  microsoft.json
  sidebysearch.json
  x.json
  yahoo.json
web/
  src/
    routes/
      api/
        services/
          [service]/
            +server.js
          +server.js
      disclaimer/
        +page.svelte
      services/
        [service]/
          +page.js
          +page.svelte
      +layout.css
      +layout.svelte
      +page.server.js
      +page.svelte
    app.html
    hooks.server.js
  package.json
  svelte.config.js
  tsconfig.json
  vite.config.js
</directory_structure>

<files>

<file path="scraper/README.md">
# ToS Diff Scraper

This scraper monitors legal document changes and uses AI to summarize them.

## Environment Setup

Create a `.env` file in the scraper directory with the following variables:

```env
# xAI Grok API Key (fallback)
XAI_API_KEY=your_xai_api_key_here

# Google Gemini API Key (primary)
GEMINI_API_KEY=your_gemini_api_key_here

# Discord Webhook URL (optional, for admin alerts)
DISCORD_WEBHOOK_URL=your_discord_webhook_url_here
```

## AI Provider Fallback

The scraper uses a fallback system:
1. **Primary**: Google Gemini 2.5 Flash (cost-efficient, reasoning enabled)
2. **Fallback**: xAI Grok 3 Mini (if Gemini fails)

Both use the same system prompt for consistent analysis.

## Usage

```bash
npm run start
```

The scraper will:
- Monitor configured services for document changes
- Use AI to summarize detected changes
- Save source HTML for verification
- Generate diff views with escaped HTML
</file>

<file path="service-config/duckduckgo.json">
{
  "service": "DuckDuckGo",
  "documents": {
    "Terms of Service": {
      "url": "https://duckduckgo.com/terms",
      "selector": "section.legal_content__mzrZi"
    },
    "Privacy Policy": {
      "url": "https://duckduckgo.com/privacy",
      "selector": "section.legal_content__mzrZi"
    },
    "Acceptable Use Policy": {
      "url": "https://duckduckgo.com/acceptable-use",
      "selector": "section.legal_section__BZR18"
    },
    "Duck.ai Privacy & Terms of Use": {
      "url": "https://duckduckgo.com/duckai/privacy-terms",
      "selector": ".content_root___2bzn"
    },
    "Privacy Pro (U.S.) Privacy Policy": {
      "url": "https://duckduckgo.com/pro/privacy-terms/us",
      "selector": "section.legal_content__mzrZi"
    },
    "Privacy Pro (non-U.S.) Privacy Policy": {
      "url": "https://duckduckgo.com/pro/privacy-terms/non-us/en",
      "selector": "section.legal_content__mzrZi"
    }
  }
}
</file>

<file path="service-config/facebook.json">
{
  "service": "Facebook",
  "documents": {
    "Privacy Policy": {
      "url": "https://mbasic.facebook.com/privacy/policy/printable/",
      "selector": "body"
    },
    "Community Standards": {
      "url": "https://transparency.meta.com/policies/community-standards/",
      "selector": "section._9ntw._9nty._9nu2"
    },
    "Commercial Terms": {
      "url": "https://mbasic.facebook.com/legal/commercial_terms",
      "selector": "body"
    },
    "Payments Terms": {
      "url": "https://mbasic.facebook.com/payments_terms",
      "selector": "body"
    },
    "Commerce Policies": {
      "url": "https://mbasic.facebook.com/policies/commerce",
      "selector": "body"
    },
    "Music Guidelines": {
      "url": "https://mbasic.facebook.com/legal/music_guidelines",
      "selector": "body"
    },
    "Self-Service Ad Terms": {
      "url": "https://mbasic.facebook.com/legal/self_service_ads_terms",
      "selector": "body"
    },
    "Pages, Groups and Events Policies": {
      "url": "https://mbasic.facebook.com/policies/pages_groups_events",
      "selector": "body"
    },
    "Developer Payments Terms": {
      "url": "https://developers.facebook.com/policy/credits",
      "selector": "div._4-u2._57mb._1u44._3fw6._4-u8"
    },
    "Recommendations Guidelines": {
      "url": "https://mbasic.facebook.com/help/1257205004624246/",
      "selector": "body"
    },
    "Live Policies": {
      "url": "https://mbasic.facebook.com/policies/live",
      "selector": "body"
    }
  }
}
</file>

<file path="service-config/instagram.json">
{
  "service": "Instagram",
  "documents": {
    "Recommendations Guidelines": {
      "url": "https://help.instagram.com/313829416281232/",
      "selector": "div.x9f619.x1n2onr6.x1ja2u2z.x78zum5.xdt5ytf.x2lah0s.x193iq5w.x13ihpsm.x1xzm06s.xqui205",
      "jsHeavy": true
    }
  }
}
</file>

<file path="service-config/meta.json">
{
  "service": "Meta",
  "documents": {
    "Privacy Policy": {
      "url": "https://www.meta.com/legal/privacy-policy/",
      "selector": "main"
    },
    "United States Regional Privacy Notice": {
      "url": "https://www.meta.com/legal/united-states/",
      "selector": "main"
    },
    "Terms of Use": {
      "url": "https://mbasic.facebook.com/legal/terms/plain_text_terms/",
      "selector": "body"
    },
    "Open Source Privacy Policy": {
      "url": "https://opensource.fb.com/legal/privacy/",
      "selector": "section.py-sm-50.py-100"
    },
    "Platform Terms": {
      "url": "https://developers.facebook.com/terms/",
      "selector": "div._4bl9._2pis[data-testid=\"platform_terms_page_content\"]"
    },
    "Avatars Terms of Service": {
      "url": "https://mbasic.facebook.com/legal/avatars_terms",
      "selector": "body"
    },
    "AI Terms of Service": {
      "url": "https://mbasic.facebook.com/legal/ai-terms",
      "selector": "body"
    },
    "UK AI Terms of Service": {
      "url": "https://mbasic.facebook.com/legal/uk-ai-terms",
      "selector": "body"
    },
    "Brazil AI Terms of Service": {
      "url": "https://mbasic.facebook.com/legal/br-ai-terms",
      "selector": "body"
    },
    "EU AI Terms of Service": {
      "url": "https://mbasic.facebook.com/legal/eu-ai-terms",
      "selector": "body"
    }
  }
}
</file>

<file path="service-config/microsoft.json">
{
  "service": "Microsoft",
  "documents": {
    "Services Agreement": {
      "url": "https://www.microsoft.com/en-us/servicesagreement",
      "selector": "div.aem-Grid.aem-Grid--12.aem-Grid--default--12"
    },
    "Terms of Use": {
      "url": "https://www.microsoft.com/en-us/legal/terms-of-use",
      "selector": "main"
    },
    "Privacy Statement": {
      "url": "https://www.microsoft.com/en-us/privacy/privacystatement",
      "selector": "div.col.text-md-left.no-gutters.col-12.col-sm-6.col-md-8[data-automation-test-id=\"column-layout-container-uid4635\"]"
    },
    "Learn Terms of Use": {
      "url": "https://learn.microsoft.com/en-us/legal/termsofuse",
      "selector": "main"
    },
    "Office Developer Program Terms": {
      "url": "https://learn.microsoft.com/en-us/office/developer-program/terms-and-conditions",
      "selector": "main"
    }
  }
}
</file>

<file path="service-config/x.json">
{
  "service": "X (formerly Twitter)",
  "documents": {
    "Terms of Service": {
      "url": "https://x.com/en/tos",
      "selector": "div.ct01__wrapper"
    },
    "Privacy Policy": {
      "url": "https://x.com/en/privacy",
      "selector": "div.root.responsivegrid"
    },
    "The X Rules": {
      "url": "https://help.x.com/en/rules-and-policies/x-rules",
      "selector": "div.root.responsivegrid"
    },
    "Information for Parents and Minor Users": {
      "url": "https://help.x.com/en/rules-and-policies/information-for-parents-and-minor-users",
      "selector": "div.ct01__column.twtr-col-md-8.none > div.ct01__wrapper"
    },
    "Authenticity": {
      "url": "https://help.x.com/en/rules-and-policies/authenticity",
      "selector": "div.root.responsivegrid"
    },
    "Civic Integrity Policy": {
      "url": "https://help.x.com/en/rules-and-policies/election-integrity-policy",
      "selector": "div.root.responsivegrid"
    },
    "Sensitive Media Policy": {
      "url": "https://help.x.com/en/rules-and-policies/adult-content",
      "selector": "div.root.responsivegrid"
    },
    "Abusive Behavior": {
      "url": "https://help.x.com/en/rules-and-policies/abusive-behavior",
      "selector": "div.root.responsivegrid"
    },
    "Child Safety": {
      "url": "https://help.x.com/en/rules-and-policies/child-safety",
      "selector": "div.root.responsivegrid"
    },
    "Non-consensual Nudity Policy": {
      "url": "https://help.x.com/en/rules-and-policies/intimate-media",
      "selector": "div.root.responsivegrid"
    },
    "Suicide and Self-harm Policy": {
      "url": "https://help.x.com/en/rules-and-policies/glorifying-self-harm",
      "selector": "div.root.responsivegrid"
    },
    "Hateful Conduct Policy": {
      "url": "https://help.x.com/en/rules-and-policies/hateful-conduct-policy",
      "selector": "div.root.responsivegrid"
    },
    "Perpetrators of Violent Attacks": {
      "url": "https://help.x.com/en/rules-and-policies/perpetrators-of-violent-attacks",
      "selector": "div.root.responsivegrid"
    },
    "Violent Content": {
      "url": "https://help.x.com/en/rules-and-policies/violent-content",
      "selector": "div.root.responsivegrid"
    },
    "Personal Information": {
      "url": "https://help.x.com/en/rules-and-policies/personal-information",
      "selector": "div.root.responsivegrid"
    },
    "Violent and Hateful Entities Policy": {
      "url": "https://help.x.com/en/rules-and-policies/violent-entities",
      "selector": "div.root.responsivegrid"
    },
    "Abusive Profile Information": {
      "url": "https://help.x.com/en/rules-and-policies/abusive-profile",
      "selector": "div.root.responsivegrid"
    },
    "Trademark Policy": {
      "url": "https://help.x.com/en/rules-and-policies/x-trademark-policy",
      "selector": "div.root.responsivegrid"
    },
    "Copyright Policy": {
      "url": "https://help.x.com/en/rules-and-policies/copyright-policy",
      "selector": "div.root.responsivegrid"
    },
    "Counterfeit Goods Policy": {
      "url": "https://help.x.com/en/rules-and-policies/counterfeit-goods-policy",
      "selector": "div.root.responsivegrid"
    },
    "Automated Claims Policy": {
      "url": "https://help.x.com/en/rules-and-policies/automated-claims-policy",
      "selector": "div.root.responsivegrid"
    }
  }
}
</file>

<file path="service-config/yahoo.json">
{
  "service": "Yahoo",
  "documents": {
    "Terms of Service": {
      "url": "https://legal.yahoo.com/us/en/yahoo/terms/otos/index.html",
      "selector": "main"
    },
    "Privacy Policy": {
      "url": "https://legal.yahoo.com/us/en/yahoo/privacy/index.html",
      "selector": "main"
    }
  }
}
</file>

<file path="web/src/routes/+page.server.js">
import fs from 'fs/promises';
import path from 'path';

export async function load() {
  const projectRoot = path.resolve('..');
  const cfgDir = path.join(projectRoot, 'service-config');
  const dataDir = path.join(projectRoot, 'web/static/data');
  const storageDir = path.join(projectRoot, 'scraper/storage');
  
  const files = await fs.readdir(cfgDir);
  
  const services = await Promise.all(
    files
      .filter(f => f.endsWith('.json'))
      .map(async (f) => {
        const serviceId = f.replace('.json', '');
        
        const serviceCfgPath = path.join(cfgDir, f);
        const serviceCfg = JSON.parse(await fs.readFile(serviceCfgPath, 'utf-8'));
        const serviceName = serviceCfg.service;
        
        let mostRecentUpdate = null;
        let updateType = '';
        
        if (serviceCfg.documents) {
          for (const docType in serviceCfg.documents) {
            const docSlug = docType.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
            
            const changesPath = path.join(dataDir, serviceId, docSlug, 'changes.json');
            try {
              const changesFile = await fs.readFile(changesPath, 'utf-8');
              const changesData = JSON.parse(changesFile);
              if (changesData.changes && changesData.changes.length > 0) {
                const latestChangeTimestamp = new Date(changesData.changes[0].timestamp);
                if (!mostRecentUpdate || latestChangeTimestamp > mostRecentUpdate) {
                  mostRecentUpdate = latestChangeTimestamp;
                  updateType = 'change';
                }
              }
            } catch {
              // No changes file, check for initial scrape
              const storagePath = path.join(storageDir, serviceName, docSlug, 'prev.html');
              try {
                const stats = await fs.stat(storagePath);
                if (!mostRecentUpdate || stats.mtime > mostRecentUpdate) {
                  mostRecentUpdate = stats.mtime;
                  updateType = 'scrape';
                }
              } catch {
                // No storage file either
              }
            }
          }
        }
        
        return {
          id: serviceId,
          name: serviceName,
          lastUpdate: mostRecentUpdate ? mostRecentUpdate.toISOString() : null,
          updateType: mostRecentUpdate ? updateType : null,
        };
      })
  );

  return { services };
}
</file>

<file path="scraper/.env">
XAI_API_KEY=xai-37RtF5CFM6f2MTUqCMupIJYusR2X8IeXEsmzKOydjQosR2IIgQH8ffnCoi4D1kS5UOrzxQbSPYZJIgxM
GEMINI_API_KEY=AIzaSyD8pK-3A-WhVcBgb1T-G_TMOYEhM-_gvg0
DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/1393484544921042955/mx97cfQ-LWe5NTJgRR0g6OJKTEZEdUzm_fl62VqEjDm_nu2C4Z3LcJY4SfIFnO35TtX7
</file>

<file path="scraper/package.json">
{
  "name": "tos-scraper",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node scraper.js"
  },
  "dependencies": {
    "@google/genai": "^1.9.0",
    "diff": "^5.1.0",
    "dotenv": "^16.0.0",
    "formdata-node": "^6.0.3",
    "openai": "^5.9.0",
    "puppeteer": "^22.8.2",
    "sanitize-html": "^2.8.1",
    "tldts": "^7.0.10"
  }
}
</file>

<file path="service-config/google.json">
{
  "service": "Google",
  "documents": {
    "Terms of Service": {
      "url": "https://policies.google.com/terms",
      "selector": "#main-content"
    },
    "Privacy Policy": {
      "url": "https://policies.google.com/privacy",
      "selector": "#main-content"
    }
  },
  "aliases": ["Google", "Alphabet"]
}
</file>

<file path="service-config/sidebysearch.json">
{
  "service": "SideBySearch",
  "documents": {
    "Privacy Policy": {
      "url": "https://sidebysearch.org/privacy",
      "selector": "main"
    }
  }
}
</file>

<file path="web/src/routes/api/services/+server.js">
import fs from 'fs/promises';
import path from 'path';

export async function GET() {
  try {
    const configDir = path.resolve('../service-config');
    const files = await fs.readdir(configDir);

    const services = await Promise.all(files
      .filter(file => file.endsWith('.json'))
      .map(async (file) => {
        const filePath = path.join(configDir, file);
        const fileContent = await fs.readFile(filePath, 'utf-8');
        const config = JSON.parse(fileContent);
        return {
          id: file.replace('.json', ''),
          name: config.service
        };
      })
    );

    return new Response(JSON.stringify(services), {
      headers: { 'Content-Type': 'application/json' },
      status: 200
    });

  } catch (error) {
    console.error('Failed to list services:', error);
    return new Response(JSON.stringify({ error: 'Could not load services' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
</file>

<file path="web/src/routes/disclaimer/+page.svelte">
<h1>Disclaimer</h1>

<p><strong>No Affiliation:</strong> This website is an independent project and is not affiliated with, endorsed by, or in any way officially connected with any of the companies whose terms of service or privacy policies are displayed here. All company names, logos, and trademarks are the property of their respective owners.</p>

<p><strong>For Informational Purposes Only:</strong> The content provided on this website is for informational purposes only. It is automatically scraped from public sources and is presented without any alteration or manual review. The goal is to provide a convenient way to track changes to these legal documents over time.</p>

<p><strong>No Legal Advice:</strong> The information on this site does not constitute, and should not be relied upon as, legal advice. We make no representations or warranties of any kind, express or implied, about the completeness, accuracy, reliability, suitability, or availability of the information contained on the website.</p>

<p><strong>Verify Information:</strong> We strongly encourage all users to review the official terms of service and privacy policies directly on the respective companies' websites before making any decisions based on the information presented here. Your legal rights and obligations are determined by the original documents.</p>

<p><strong>Limitation of Liability:</strong> In no event will we be liable for any loss or damage including without limitation, indirect or consequential loss or damage, or any loss or damage whatsoever arising from loss of data or profits arising out of, or in connection with, the use of this website.</p>

<style>
  h1 {
    margin-bottom: 2rem;
  }
  p {
    margin-bottom: 1rem;
    line-height: 1.6;
    max-width: 80ch;
  }
  p strong {
    color: var(--text-primary);
    font-weight: 700;
  }
</style>
</file>

<file path="web/src/app.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.png" />
    <meta name="viewport" content="width=device-width" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    %sveltekit.head%
  </head>
  <body>
    <div style="display: contents">
      %sveltekit.body%
    </div>
  </body>
</html>
</file>

<file path="web/package.json">
{
  "name": "tos-diff-web",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite dev",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@sveltejs/kit": "^2.22.5",
    "svelte": "^5.0.0"
  },
  "devDependencies": {
    "@sveltejs/adapter-static": "^3.0.8",
    "@types/estree": "^1.0.8",
    "svelte-preprocess": "^6.0.3"
  },
  "overrides": {
    "cookie": "0.7.1"
  }
}
</file>

<file path="web/tsconfig.json">
{
  "extends": "./.svelte-kit/tsconfig.json",
  "compilerOptions": {
    "strict": true,
    "skipLibCheck": true,
    "types": []
  }
}
</file>

<file path="web/vite.config.js">
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [sveltekit()]
});
</file>

<file path=".github/workflows/scraper.yml">
name: Automated Document Scraper

on:
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch: # Allow manual triggering

jobs:
  scrape:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: Install dependencies
      run: |
        cd scraper
        npm install
        
    - name: Run scraper
      env:
        # These secrets are configured in GitHub repository settings
        XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        node scraper/scraper.js
        
    - name: Check for changes
      id: check_changes
      run: |
        if [ -n "$(git status --porcelain)" ]; then
          echo "has_changes=true" >> $GITHUB_OUTPUT
        else
          echo "has_changes=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Commit and push changes
      if: steps.check_changes.outputs.has_changes == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        git commit -m "Auto-update: Document changes detected $(date)"
        git push
</file>

<file path="web/src/routes/api/services/[service]/+server.js">
import fs from 'fs/promises';
import path from 'path';

export async function GET({ params }) {
  try {
    const serviceName = params.service.toLowerCase();
    
    const configPath = path.resolve('../service-config', `${serviceName}.json`);
    
    const fileContent = await fs.readFile(configPath, 'utf-8');
    const config = JSON.parse(fileContent);
    
    const documents = Object.keys(config.documents || {});
    
    return new Response(JSON.stringify({
      serviceName: config.service,
      documents
    }), {
      headers: { 'Content-Type': 'application/json' },
      status: 200
    });

  } catch (error) {
    return new Response(JSON.stringify({ error: 'Service not found' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
</file>

<file path="web/src/routes/services/[service]/+page.js">
export async function load({ params, fetch }) {
  try {
    const svc = params.service.toLowerCase();

    const docsRes = await fetch(`/api/services/${svc}`);
    if (!docsRes.ok) {
      return { service: params.service, documents: {}, activeTab: null };
    }
    const { serviceName, documents: docNames } = await docsRes.json();

    const slugify = (text) => text.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
    const promises = docNames.map(docName =>
      fetch(`/data/${svc}/${slugify(docName)}/changes.json`)
    );
    const results = await Promise.allSettled(promises);

    const documents = {};
    for (let i = 0; i < docNames.length; i++) {
      const docName = docNames[i];
      const res = results[i];
      let changes = [];
      if (res.status === 'fulfilled' && res.value.ok) {
        const data = await res.value.json();
        changes = data.changes || (Array.isArray(data) ? data : []);
      }
      documents[docName] = { changes };
    }

    return {
      service: serviceName,
      documents,
      activeTab: docNames.length > 0 ? docNames[0] : null
    };

  } catch (error) {
    console.error("Failed to load service changes:", error);
    return {
      service: params.service,
      documents: {},
      activeTab: null
    };
  }
}
</file>

<file path="web/src/routes/+layout.css">
:root {
  --background: #112;
  --surface: #223;
  --primary: #48f;
  --on-primary: #fff;
  --text-primary: #eee;
  --text-secondary: #ccc;
  --border: #334;
  --added-bg: #4ba1;
  --removed-bg: #f431;
  --added-color: #48f;
  --removed-color: #f44;
}

.added {
  background-color: var(--added-bg);
  color: var(--added-color);
}
.removed {
  background-color: var(--removed-bg);
  color: var(--removed-color);
}

body {
  font-family: 'Inter', sans-serif;
  margin: 0;
  padding: 0;
  background-color: var(--background);
  color: var(--text-primary);
  line-height: 1.6;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1.5rem 2rem;
  border-bottom: 1px solid var(--border);
}

.logo {
  font-weight: 700;
  font-size: 1.2rem;
  text-decoration: none;
  color: var(--text-primary);
}

main {
  padding: 2rem;
}

nav {
  display: flex;
  gap: 1.5rem;
  padding-bottom: 2rem;
  border-bottom: 1px solid var(--border);
  margin-bottom: 2rem;
}

nav a {
  text-decoration: none;
  font-weight: bold;
  color: var(--text-secondary);
  transition: color 0.2s ease-in-out;
}

nav a:hover {
  color: var(--primary);
}

h1, h2, h3 {
  color: var(--text-primary);
  font-weight: 700;
}

a {
  color: var(--primary);
}
</file>

<file path="web/src/routes/+layout.svelte">
<script>
  import './+layout.css';
</script>

<header>
  <a href="/" class="logo">Legal Document Changes</a>
  <nav>
    <a href="/disclaimer">Disclaimer</a>
  </nav>
</header>

<main>
  <slot />
</main>
</file>

<file path="web/src/routes/+page.svelte">
<script>
  export let data;

  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
</script>

<div class="hero">
  <h1>Track Legal Document Changes</h1>
  <p>An automated watchdog for Terms of Service and Privacy Policy updates from major tech companies.</p>
</div>

<div class="service-grid">
  {#each data.services as service}
    <a href={`/services/${service.id}`} class="service-card">
      <img src={`/favicons/${service.name}.ico`} alt="{service.name} Favicon" class="favicon" on:error={(e) => e.target.style.display = 'none'}>
      <h3>{service.name}</h3>
      {#if service.lastUpdate}
        <p class="last-update">
          {#if service.updateType === 'change'}
            Last change:
          {:else}
            No changes since
          {/if}
          {new Date(service.lastUpdate).toLocaleDateString()}
        </p>
      {/if}
    </a>
  {/each}
</div>

<style>
  .hero {
    text-align: center;
    margin-bottom: 4rem;
  }

  .hero h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
  }

  .hero p {
    font-size: 1.1rem;
    color: var(--text-secondary);
    max-width: 60ch;
    margin: 0 auto;
  }

  .service-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 1.5rem;
  }

  .service-card {
    background-color: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 2rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    text-decoration: none;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  .favicon {
    width: 48px;
    height: 48px;
    object-fit: contain;
  }

  .service-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
  }

  .service-card h3 {
    margin: 0;
    font-size: 1.5rem;
    color: var(--text-primary);
  }

  .last-update {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin: 0;
  }
</style>
</file>

<file path="web/src/hooks.server.js">
import { dev } from '$app/environment';

export const handle = async ({ event, resolve }) => {
  const response = await resolve(event);

  if (!event.isSubRequest) {
    const csp = [
      "default-src 'self'",
      `script-src 'self' ${dev ? "'unsafe-inline'" : ''}`,
      `style-src 'self' https://fonts.googleapis.com ${dev ? "'unsafe-inline'" : ''}`,
      "font-src 'self' https://fonts.gstatic.com",
      `connect-src 'self' ${dev ? 'ws:' : ''}`,
    ]
      .join('; ')
      .trim();

    response.headers.set('Content-Security-Policy', csp);
    response.headers.set(
      'Strict-Transport-Security',
      'max-age=31536000; includeSubDomains'
    );
  }

  return response;
};
</file>

<file path="web/svelte.config.js">
import adapter from '@sveltejs/adapter-static';
import preprocess from 'svelte-preprocess';

export default {
  preprocess: preprocess(),
  kit: {
    adapter: adapter({
      pages: 'build',
      assets: 'build',
      fallback: '200.html',
      strict: false
    })
  }
};
</file>

<file path="scraper/scraper.js">
import fs from 'fs/promises';
import path from 'path';
import { createHash } from 'crypto';
import puppeteer from 'puppeteer';
import sanitizeHtml from 'sanitize-html';
import { diffLines } from 'diff';
import OpenAI from 'openai';
import { GoogleGenAI } from '@google/genai';
import { getDomain } from 'tldts';
import dotenv from 'dotenv';

const scriptDirForEnv = path.dirname(import.meta.url.substring(7));
dotenv.config({ path: path.resolve(scriptDirForEnv, '.env') });

const xai = new OpenAI({
  apiKey: process.env.XAI_API_KEY,
  baseURL: 'https://api.x.ai/v1'
});

const USER_AGENTS = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:125.0) Gecko/20100101 Firefox/125.0',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4.1 Safari/605.1.15',
];

const FAILURES_LOG = 'failures.log';
const AI_RETRIES = 3;
const MIN_CONTENT_LENGTH = 256; // Minimum characters for a valid scrape
const USE_AI = true; // Set to false to disable AI summaries for testing

async function sendDiscordAlert({ title, message, level = 'INFO' }) {
  const webhookUrl = process.env.DISCORD_WEBHOOK_URL;
  if (!webhookUrl) {
    const logMessage = `${new Date().toISOString()} - DISCORD_ALERT_SKIPPED (no webhook): ${JSON.stringify({title, message})}\n`;
    await fs.appendFile(FAILURES_LOG, logMessage);
    console.warn(`Discord alert triggered but no DISCORD_WEBHOOK_URL is set. Title: ${title}`);
    return;
  }

  const color = {
    'INFO': 3447003,    // Blue
    'SUCCESS': 3066993,  // Green
    'WARN': 15105570,   // Orange
    'ERROR': 15158332,  // Red
  }[level];

  const embed = {
    title: title,
    description: message,
    color: color,
    timestamp: new Date().toISOString(),
  };

  try {
    await fetch(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ embeds: [embed] }),
    });
    console.log(`Discord alert sent: ${title}`);
  } catch (error) {
    console.error('Failed to send Discord alert:', error.message);
    const logMessage = `${new Date().toISOString()} - DISCORD_ALERT_FAILED: ${JSON.stringify({title, message})}\n`;
    await fs.appendFile(FAILURES_LOG, logMessage);
  }
}

async function generateWithGemini(prompt, systemPrompt) {
  const ai = new GoogleGenAI({});
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [
      { role: "user", parts: [{ text: systemPrompt }] },
      { role: "user", parts: [{ text: prompt }] }
    ],
    config: {
      thinkingConfig: {
        thinkingBudget: -1,
      },
    }
  });

  return response.text;
}

async function generateWithGrok(messages) {
  const completion = await xai.chat.completions.create({
    model: 'grok-3-mini',
    messages: messages,
    reasoning_effort: 'high'
  });
  
  return completion.choices[0].message.content;
}

async function generateWithFallback(prompt, systemPrompt) {
  try {
    console.log('Attempting Gemini AI...');
    const result = await generateWithGemini(prompt, systemPrompt);
    console.log('Gemini AI succeeded');
    return result;
  } catch (error) {
    console.warn(`Gemini failed: ${error.message}, falling back to Grok`);
    try {
      const messages = [
        { role: "system", content: systemPrompt },
        { role: "user", content: prompt }
      ];
      const result = await generateWithGrok(messages);
      console.log('Grok fallback succeeded');
      return result;
    } catch (grokError) {
      console.error(`Both AI providers failed. Grok error: ${grokError.message}`);
      throw grokError;
    }
  }
}

async function alertAdmin(details) {
  const message = `
**Service:** ${details.service}
**Document:** ${details.docType}
---
**Raw AI Response:**
\`\`\`
${details.rawResponse}
\`\`\`
  `;

  await sendDiscordAlert({
    title: '🚨 Admin Alert Triggered',
    message,
    level: 'ERROR',
  });
}

async function updateConfig(serviceName, docType, jsHeavyFlag) {
  const filePath = path.resolve(scriptDirForEnv, '../service-config', `${serviceName.toLowerCase()}.json`);
  try {
    const fileContent = await fs.readFile(filePath, 'utf-8');
    const config = JSON.parse(fileContent);

    if (config.documents && config.documents[docType]) {
      config.documents[docType].jsHeavy = jsHeavyFlag;
      // Write back with pretty printing
      await fs.writeFile(filePath, JSON.stringify(config, null, 2));
      const successMessage = `Permanently set 'jsHeavy: ${jsHeavyFlag}' for ${serviceName} - ${docType}.`;
      console.log(successMessage);
      await sendDiscordAlert({ title: 'Scraping Strategy Updated', message: successMessage, level: 'INFO' });
    }
  } catch (error) {
    const errorMessage = `Failed to update config for ${serviceName} at ${filePath}: ${error.message}`;
    console.error(errorMessage);
    await sendDiscordAlert({ title: 'Config Update Failed', message: errorMessage, level: 'ERROR' });
  }
}

function getRandomDelay() {
  return Math.floor(Math.random() * 6000) + 2000;
}

function normalizeUrls(html) {
  return html.replace(/href="([^"]+)"/g, (match, url) => {
    // First, decode HTML entities within the URL string.
    let processedUrl = url.replace(/&amp;/g, '&');

    // Handle Facebook's relative video redirect URLs
    if (processedUrl.startsWith('/video_redirect/')) {
      const srcParamMatch = processedUrl.match(/[?&]src=([^&]+)/);
      if (srcParamMatch && srcParamMatch[1]) {
        try {
          processedUrl = decodeURIComponent(srcParamMatch[1]);
        } catch (decodeError) { /* Ignore malformed URI, leave as is */ }
      }
    }

    // Now, process as a full URL to handle absolute redirects and tracking params
    try {
      let urlObj = new URL(processedUrl);

      // Handle Facebook's absolute redirector
      if (urlObj.hostname.endsWith('facebook.com') && urlObj.pathname === '/l.php') {
        const actualUrl = urlObj.searchParams.get('u');
        if (actualUrl) {
          // If we get the inner URL, replace and re-parse it
          processedUrl = decodeURIComponent(actualUrl);
          urlObj = new URL(processedUrl);
        }
      }
      
      const paramsToRemove = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content', 'fbclid', 'gclid'];
      paramsToRemove.forEach(param => urlObj.searchParams.delete(param));
      
      processedUrl = urlObj.toString();

    } catch (error) {
      // Not a full URL (e.g., mailto:, tel:, #anchor). Leave `processedUrl` as is.
    }
    
    return url === processedUrl ? match : `href="${processedUrl}"`;
  });
}

function formatHtml(html) {
  // Use prettier to format the HTML, making diffs cleaner
  // This is a placeholder for now, as adding prettier is a larger change.
  return html.replace(/^\s*\n/gm, ''); // Basic formatting: remove blank lines
}

function getHeaderContextByLine(html) {
  const lines = html.split(/\r?\n/);
  const headerContextByLine = [];
  let currentHeaderStack = [];
  const headerRegex = /<h([1-6]).*?>(.*?)<\/h\1>/i;

  for (const line of lines) {
    const match = line.match(headerRegex);
    if (match) {
      const level = parseInt(match[1], 10);
      const text = sanitizeHtml(match[2], { allowedTags: [], allowedAttributes: {} }).trim();

      while (currentHeaderStack.length > 0 && currentHeaderStack[currentHeaderStack.length - 1].level >= level) {
        currentHeaderStack.pop();
      }
      currentHeaderStack.push({ level, text });
    }
    headerContextByLine.push([...currentHeaderStack].map(h => h.text));
  }

  return headerContextByLine;
}

async function attemptScrape(page, selector, isJsHeavy) {
  try {
    if (isJsHeavy) {
      console.log(`Using 'jsHeavy' strategy, waiting for selector: "${selector}"`);
      await page.waitForSelector(selector, { timeout: 30000, visible: true });
    }
    
    const raw = await page.$eval(selector, el => el.innerHTML);

    if (raw.length < MIN_CONTENT_LENGTH) {
      console.warn(`Scraped content is suspiciously small (${raw.length} chars). Discarding.`);
      // No alert here, as the calling function will handle the failure and potential retry.
      return null;
    }
    
    return raw;

  } catch (error) {
    console.warn(`'${isJsHeavy ? 'jsHeavy' : 'Default'}' scrape failed for selector "${selector}": ${error.message}`);
    return null;
  }
}

async function scrapeDocument(page, cfg, docType, docSlug, url, selector, systemPrompt, { fetchFavicon = false }) {
  try {
    console.log(`Scraping ${cfg.service} ${docType}...`);
    
    // Use 'domcontentloaded' as default - more reliable for modern sites with continuous background activity
    // 'networkidle0' often fails on sites with analytics, websockets, or continuous polling
    await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });

    if (fetchFavicon) {
      let faviconUrl;
      try {
        // 1. Standard link[rel="icon"] tags
        faviconUrl = await page.evaluate(() => {
          const selectors = [
            'link[rel="icon"]',
            'link[rel="shortcut icon"]',
            'link[rel="apple-touch-icon"]'
          ];
          for (const selector of selectors) {
            const link = document.querySelector(selector);
            if (link) return link.href;
          }
          return null;
        });

        // 2. Fallback to base domain /favicon.ico
        if (!faviconUrl) {
          console.log(`No standard favicon link found for ${cfg.service}. Trying base domain.`);
          const pageUrl = page.url();
          const origin = new URL(pageUrl).origin;
          const fallbackUrl = `${origin}/favicon.ico`;
          const response = await fetch(fallbackUrl);
          if (response.ok) {
            faviconUrl = fallbackUrl;
          } else {
            console.log(`Base domain favicon at ${fallbackUrl} not found.`);
          }
        }

        // 3. Fallback to first .ico link in <head>
        if (!faviconUrl) {
          console.log(`No base domain favicon found for ${cfg.service}. Searching for any .ico link.`);
          faviconUrl = await page.evaluate(() => {
            const link = document.querySelector('head link[href$=".ico"]');
            return link ? link.href : null;
          });
        }

        if (faviconUrl) {
          const response = await fetch(faviconUrl);
          if (!response.ok) {
            throw new Error(`Failed to fetch favicon from ${faviconUrl}, status: ${response.status}`);
          }
          const buffer = await response.arrayBuffer();
          const faviconDir = path.resolve(scriptDirForEnv, '../web/static/favicons');
          await fs.mkdir(faviconDir, { recursive: true });
          const faviconPath = path.join(faviconDir, `${cfg.service}.ico`);
          await fs.writeFile(faviconPath, Buffer.from(buffer));
          console.log(`Saved favicon for ${cfg.service} from ${faviconUrl}`);
        } else {
          const errorMessage = `Could not find favicon for ${cfg.service} after all fallbacks.`;
          console.warn(errorMessage);
          await sendDiscordAlert({ title: 'Favicon Not Found', message: errorMessage, level: 'WARN' });
        }
      } catch (error) {
        const errorMessage = `Failed to fetch or save favicon for ${cfg.service}: ${error.message}`;
        console.warn(errorMessage);
        await sendDiscordAlert({ title: 'Favicon Fetch Failed', message: errorMessage, level: 'ERROR' });
      }
    }

    const docConfig = cfg.documents[docType] || {};
    const initialStrategyIsJsHeavy = !!docConfig.jsHeavy;

    let raw = await attemptScrape(page, selector, initialStrategyIsJsHeavy);

    if (!raw) {
      const fallbackStrategy = !initialStrategyIsJsHeavy;
      console.log(`Initial scrape failed. Trying fallback strategy ('jsHeavy: ${fallbackStrategy}')...`);
      raw = await attemptScrape(page, selector, fallbackStrategy);

      if (raw) {
        // Fallback succeeded, make it permanent
        await updateConfig(cfg.service, docType, fallbackStrategy);
      }
    }

    if (!raw) {
      const errorMessage = `All scraping attempts failed for ${cfg.service} ${docType} with selector "${selector}".`;
      console.error(errorMessage);
      await sendDiscordAlert({ title: 'Scraping Failed', message: errorMessage, level: 'ERROR' });
      return;
    }

    const sourceHash = createHash('sha256').update(raw).digest('hex');

    let clean = sanitizeHtml(raw, {
      allowedTags: [
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'a', 'b', 'i', 'strong', 'em', 'ul', 'ol', 'li', 'blockquote', 'pre', 'code', 'br', 'hr', 'table', 'thead', 'tbody', 'tr', 'th', 'td'
      ],
      allowedAttributes: {
        'a': ['href', 'target', 'rel']
      }
    });

    clean = normalizeUrls(clean);
    clean = formatHtml(clean);

    if (clean.length < MIN_CONTENT_LENGTH) {
      const errorMessage = `Scraped content for ${cfg.service} ${docType} is suspiciously small (${clean.length} chars).`;
      console.warn(errorMessage);
      await sendDiscordAlert({ title: 'Low Content Warning', message: errorMessage, level: 'WARN' });
    }

    const storage = path.resolve(scriptDirForEnv, 'storage', cfg.service, docSlug);
    await fs.mkdir(storage, { recursive: true });
    const prevFile = path.join(storage, 'prev.html');
    let prev = '';
    let isFirstRun = false;
    try {
      prev = await fs.readFile(prevFile, 'utf-8');
    } catch {
      isFirstRun = true;
    }

    if (prev === clean) {
      console.log(`No changes detected for ${cfg.service} ${docType}`);
      return;
    }

    if (isFirstRun) {
      await fs.writeFile(prevFile, clean);
      console.log(`Initial content saved for ${cfg.service} ${docType}. No diff generated on first run.`);
      return;
    }

    await fs.writeFile(prevFile, clean);

    const prevHeaderContext = getHeaderContextByLine(prev);
    const cleanHeaderContext = getHeaderContextByLine(clean);
    
    const diff = diffLines(prev, clean);

    if (!diff.some(part => part.added || part.removed)) {
      console.log(`No significant changes detected (whitespace only) for ${cfg.service} ${docType}`);
      return;
    }

    let diffTextForAI = '';
    let lastHeadersJson = '';
    let prevLineNum = 0;
    let cleanLineNum = 0;

    for (const part of diff) {
      if (part.added) {
        const headers = cleanHeaderContext[cleanLineNum];
        const headersJson = JSON.stringify(headers);
        if (headers && headers.length > 0 && headersJson !== lastHeadersJson) {
          diffTextForAI += `\n[Context: ${headers.join(' > ')}]\n`;
          lastHeadersJson = headersJson;
        }
        diffTextForAI += part.value.split(/\r?\n/).filter(l => l).map(line => `+ ${line}`).join('\n') + '\n';
        cleanLineNum += part.count;
      } else if (part.removed) {
        const headers = prevHeaderContext[prevLineNum];
        const headersJson = JSON.stringify(headers);
        if (headers && headers.length > 0 && headersJson !== lastHeadersJson) {
          diffTextForAI += `\n[Context: ${headers.join(' > ')}]\n`;
          lastHeadersJson = headersJson;
        }
        diffTextForAI += part.value.split(/\r?\n/).filter(l => l).map(line => `- ${line}`).join('\n') + '\n';
        prevLineNum += part.count;
      } else {
        prevLineNum += part.count;
        cleanLineNum += part.count;
        lastHeadersJson = '';
      }
    }
    
    const diffHtml = diff.map(part => {
      const className = part.added ? 'added' : part.removed ? 'removed' : '';
      const escapedValue = part.value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      if (className) {
        return `<div class="${className}">${escapedValue}</div>`;
      }
      return `<div>${escapedValue}</div>`;
    }).join('');

    let summaryLines;

    if (USE_AI) {
      const prompt = `Summarize these ${docType} changes as a Markdown bullet list. The changes are provided in a diff format, with lines prefixed by '+' for additions and '-' for removals. Header context is provided in [Context: ...] blocks. The diff contains HTML, so interpret it accordingly:\n\n${diffTextForAI}`;
      
      let aiResponse;
      let lastError = null;

      for (let i = 0; i < AI_RETRIES; i++) {
        try {
          aiResponse = await generateWithFallback(prompt, systemPrompt);
          lastError = null;
          break;
        } catch (error) {
          lastError = error;
          console.warn(`AI completion failed for ${cfg.service} ${docType} (attempt ${i + 1}/${AI_RETRIES}):`, error.message);
          if (i < AI_RETRIES - 1) {
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        }
      }

      if (lastError) {
        const errorMessage = `AI processing failed for ${cfg.service} ${docType} after ${AI_RETRIES} attempts: ${lastError.message}`;
        console.error(errorMessage);
        await sendDiscordAlert({ title: 'AI Processing Failed', message: errorMessage, level: 'ERROR' });
        const logMessage = `${new Date().toISOString()} - AI_FAILED: ${JSON.stringify({ service: cfg.service, docType, error: lastError.message })}\n`;
        await fs.appendFile(FAILURES_LOG, logMessage);
        return;
      }
      
      if (aiResponse.includes('alert_admin()')) {
        await alertAdmin({
          service: cfg.service,
          docType: docType,
          rawResponse: aiResponse
        });
      }

      summaryLines = aiResponse
        .replace(/alert_admin\(\)/g, '')
        .trim()
        .split(/\r?\n/)
        .filter(line => Boolean(line) && !line.includes('[ADMIN]'))
        .map(l => `<p>${l}</p>`);
    } else {
      console.log(`AI processing skipped for ${cfg.service} ${docType} because USE_AI is false.`);
      summaryLines = [`<p>AI summary disabled for testing. Changes were detected.</p>`];
    }

    const outDir = path.resolve(scriptDirForEnv, '../web/static/data', cfg.service.toLowerCase(), docSlug);
    await fs.mkdir(outDir, { recursive: true });
    const changesFile = path.join(outDir, 'changes.json');

    let data = { schemaVersion: 2, changes: [] };
    try {
      const fileContent = await fs.readFile(changesFile, 'utf-8');
      const existingData = JSON.parse(fileContent);
      if (Array.isArray(existingData)) {
        data.changes = existingData;
      } else if (existingData && typeof existingData === 'object') {
        data = existingData;
      }
    } catch {}

    const timestamp = new Date().toISOString();
    const sourceHtmlFile = `${new Date(timestamp).getTime()}-source.html`;
    await fs.writeFile(path.join(outDir, sourceHtmlFile), raw);

    data.changes.unshift({
      timestamp: timestamp,
      type: docType,
      summary: summaryLines,
      diffHtml,
      sourceHash,
      sourceHtmlFile
    });
    await fs.writeFile(changesFile, JSON.stringify(data, null, 2));
    
    console.log(`Changes detected and processed for ${cfg.service} ${docType}`);
    const alertMessage = `
**Service:** ${cfg.service}
**Document:** [${docType}](${url})
---
**Summary of Changes:**
${summaryLines.map(p => p.replace(/<p>/g, '').replace(/<\/p>/g, '')).join('\n')}
    `;
    await sendDiscordAlert({
      title: `✅ Changes Detected: ${cfg.service} ${docType}`,
      message: alertMessage,
      level: 'SUCCESS'
    });

  } catch (error) {
    const errorMessage = `An unexpected error occurred in scrapeDocument for ${cfg.service} ${docType} at ${url}: ${error.message}`;
    console.error(errorMessage, error.stack);
    await sendDiscordAlert({ title: 'Unhandled Scraper Error', message: errorMessage, level: 'ERROR' });
    const logMessage = `${new Date().toISOString()} - UNHANDLED_ERROR: ${JSON.stringify({ service: cfg.service, docType, url, error: error.message })}\n`;
    await fs.appendFile(FAILURES_LOG, logMessage);
  }
}

async function main() {
  const scriptDir = path.dirname(import.meta.url.substring(7));
  const systemPromptPath = path.resolve(scriptDir, 'system_prompt.txt');
  const systemPrompt = await fs.readFile(systemPromptPath, 'utf-8');
  
  await fs.mkdir('web/static/data', { recursive: true }).catch(() => {});
  
  console.log('Loading service configurations...');
  const cfgDir = path.resolve(scriptDir, '../service-config');
  const files = await fs.readdir(cfgDir);
  
  const allTasks = [];
  for (const f of files) {
    if (!f.endsWith('.json')) continue;
    const cfg = JSON.parse(await fs.readFile(path.join(cfgDir, f), 'utf-8'));
    if (!cfg.documents) continue;

    for (const docType in cfg.documents) {
      const docConfig = cfg.documents[docType];
      if (docConfig.url && docConfig.selector) {
        allTasks.push({
          cfg,
          docType,
          docConfig,
          docSlug: docType.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, ''),
        });
      }
    }
  }

  const tasksByDomain = allTasks.reduce((acc, task) => {
    const domain = getDomain(task.docConfig.url);
    if (domain) {
      if (!acc[domain]) acc[domain] = [];
      acc[domain].push(task);
    }
    return acc;
  }, {});
  
  console.log(`Found ${allTasks.length} documents to scrape across ${Object.keys(tasksByDomain).length} domains.`);

  let browser;
  try {
    console.log('Launching browser...');
    browser = await puppeteer.launch({ args: ['--no-sandbox'] });

    const processedFavicons = new Set();
    
    const domainPromises = Object.values(tasksByDomain).map(async (domainTasks) => {
      const page = await browser.newPage();
      const userAgent = USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];
      await page.setUserAgent(userAgent);
      
      console.log(`[Worker] Starting domain ${getDomain(domainTasks[0].docConfig.url)} with ${domainTasks.length} tasks.`);

      for (const task of domainTasks) {
        const serviceName = task.cfg.service;
        let shouldFetchFavicon = false;
        if (!processedFavicons.has(serviceName)) {
          const faviconDir = path.resolve(scriptDirForEnv, '../web/static/favicons');
          try {
            await fs.access(path.join(faviconDir, `${serviceName}.ico`));
            processedFavicons.add(serviceName); // Mark as processed even if it exists
          } catch {
            shouldFetchFavicon = true;
            processedFavicons.add(serviceName); // Mark as processed to avoid race conditions
          }
        }
        
        await scrapeDocument(page, task.cfg, task.docType, task.docSlug, task.docConfig.url, task.docConfig.selector, systemPrompt, { fetchFavicon: shouldFetchFavicon });
        
        console.log(`Polite delay before next request to ${getDomain(task.docConfig.url)}...`);
        await new Promise(resolve => setTimeout(resolve, getRandomDelay()));
      }
      
      // Page is closed after all tasks for the domain are complete
      await page.close();
    });

    await Promise.all(domainPromises);

  } catch (error) {
    console.error('Error in main execution:', error);
  } finally {
    if (browser) {
      console.log('Closing browser...');
      await browser.close();
    }
  }
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
</file>

<file path="scraper/system_prompt.txt">
When you receive diffs of Legal Document changes, summarize them as a Markdown bullets

1. Start each bullet with 1+ type tags in square brackets.
   - If there's a single applicable category, use `[Category]`.
   - If multiple apply, list them comma-separated within the same brackets, `[Data Sharing, Consent Requirement]`.
2. After the closing bracket, put a concise description of the change in plain English.
3. Use these categories (case-sensitive):
   - New Obligation
   - Privacy Impact
   - Data Sharing
   - Tracking Change
   - Consent Requirement
   - Permission Grant
   - Security Update
   - Payment Terms
   - Termination Clause
   - Retention Policy
   - Third-Party Integration
   - Age Restriction
   - Service Modification
   - Typo Fix
   - Formatting Change
   - Clarification
4. If a change does not clearly match any category, use `[Clarification]`.
5. Do not include any other text outside the bullet list. Example output:
   - [Data Sharing] Third-party analytics provider X added to Section 4.
   - [Typo Fix] Corrected "privact" to "privacy" in subsection 2.
6. If a change has severe implications that require immediate human review, add a special bullet point at the end of your summary: `- [ADMIN] alert_admin()`. This should be reserved for critical issues.
7. Use the `[ADMIN]` tag for truly significant changes ONLY, such as new clauses that dramatically alter user rights, enable widespread data sharing with third parties without clear user consent, or introduce significant new legal liabilities. Do not use it for minor clarifications, cookie policy adjustments (unless they represent a fundamental shift in tracking), or routine updates.
</file>

<file path="web/src/routes/services/[service]/+page.svelte">
<script>
  export let data;

  let activeTab = data.activeTab;

  function setActiveTab(tab) {
    activeTab = tab;
  }

  async function copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      alert('Hash copied to clipboard!');
    } catch (err) {
      console.error('Failed to copy text: ', err);
    }
  }
</script>

<h1>{data.service} Legal Document Changes</h1>

{#if data.documents && Object.keys(data.documents).length > 0}
  <div class="tabs">
    {#each Object.keys(data.documents) as docName}
      <button
        class:active={activeTab === docName}
        on:click={() => setActiveTab(docName)}
        disabled={data.documents[docName].changes.length === 0}
      >
        {docName} ({data.documents[docName].changes.length})
      </button>
    {/each}
  </div>

  {#if activeTab && data.documents[activeTab]}
    {@const currentDoc = data.documents[activeTab]}
    <div class="content">
      {#if currentDoc.changes.length === 0}
        <p>No {activeTab} changes detected yet.</p>
      {:else}
        {#each currentDoc.changes as change}
          <section>
            <div class="change-meta">
              <h2>{new Date(change.timestamp).toLocaleString()}</h2>
              <div class="meta-controls">
                {#if change.sourceHtmlFile}
                  <a href="/data/{data.service.toLowerCase()}/{activeTab.toLowerCase().replace(/\s+/g, '-')}/{change.sourceHtmlFile}" target="_blank" class="source-link">
                    View Source
                  </a>
                {/if}
                {#if change.sourceHash}
                  <button
                    type="button"
                    class="source-hash"
                    title="Click to copy full hash: {change.sourceHash}"
                    on:click={() => copyToClipboard(change.sourceHash)}
                  >
                    Source Hash: {change.sourceHash.substring(0, 12)}...
                  </button>
                {/if}
              </div>
            </div>
            <div class="summary">
              {@html change.summary.join('')}
            </div>
            <details>
              <summary>View full diff</summary>
              <div class="diff">
                {@html change.diffHtml}
              </div>
            </details>
          </section>
        {/each}
      {/if}
    </div>
  {/if}
{:else}
  <p>No documents are configured for this service yet.</p>
{/if}

<style>
  h1 {
    text-transform: none;
  }
  .tabs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 2rem;
    border-bottom: 1px solid var(--border);
  }

  .tabs button {
    padding: 0.75rem 1.25rem;
    border: none;
    background: transparent;
    cursor: pointer;
    border-radius: 6px 6px 0 0;
    font-size: 1rem;
    color: var(--text-secondary);
    position: relative;
    top: 1px;
    transition: background-color 0.2s ease, color 0.2s ease;
  }

  .tabs button:disabled {
    color: var(--text-secondary);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tabs button.active {
    background: var(--background);
    color: var(--primary);
    border-bottom: 2px solid var(--primary);
  }

  .tabs button:not(.active):not(:disabled):hover {
    background-color: var(--surface);
    color: var(--text-primary);
  }

  .content {
    margin-top: 1rem;
  }

  section {
    margin-bottom: 2rem;
    padding: 1.5rem;
    border: 1px solid var(--border);
    border-radius: 8px;
    background-color: var(--surface);
  }

  .change-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
  }

  .meta-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  section h2 {
    font-size: 1rem;
    font-weight: normal;
    color: var(--text-secondary);
    margin: 0;
  }

  .source-link {
    font-size: 0.8em;
    color: var(--text-secondary);
    text-decoration: none;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    transition: background-color 0.2s;
  }

  .source-link:hover {
    background-color: var(--border);
    text-decoration: underline;
  }

  .source-hash {
    font-family: 'Roboto Mono', monospace;
    font-size: 0.8em;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    transition: background-color 0.2s;
    background: none;
    border: none;
    text-align: left;
  }

  .source-hash:hover {
    background-color: var(--border);
  }

  .summary {
    margin: 1rem 0;
  }

  .summary :global(p) {
    margin: 0.5rem 0;
  }

  details {
    margin-top: 1.5rem;
  }

  details summary {
    cursor: pointer;
    font-weight: bold;
    color: var(--text-secondary);
  }

  details summary:hover {
    color: var(--primary);
  }

  .diff {
    margin-top: 1rem;
    padding: 1rem;
    background: var(--background);
    border-radius: 4px;
    font-family: 'Roboto Mono', monospace;
    white-space: pre-wrap;
    font-size: 0.9em;
    border: 1px solid var(--border);
  }
</style>
</file>

</files>
