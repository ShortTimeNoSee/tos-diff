This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    scraper.yml
scraper/
  .env
  package.json
  scraper.js
  system_prompt.txt
service-config/
  google.json
  sidebysearch.json
web/
  src/
    lib/
      services.js
    routes/
      api/
        services/
          [service]/
            +server.js
      disclaimer/
        +page.svelte
      services/
        [service]/
          +page.js
          +page.svelte
      +layout.css
      +layout.svelte
      +page.svelte
    app.html
    hooks.server.js
  package.json
  svelte.config.js
  tsconfig.json
  vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="scraper/.env">
XAI_API_KEY=xai-37RtF5CFM6f2MTUqCMupIJYusR2X8IeXEsmzKOydjQosR2IIgQH8ffnCoi4D1kS5UOrzxQbSPYZJIgxM
DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/1393484544921042955/mx97cfQ-LWe5NTJgRR0g6OJKTEZEdUzm_fl62VqEjDm_nu2C4Z3LcJY4SfIFnO35TtX7
</file>

<file path="scraper/package.json">
{
  "name": "tos-scraper",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node scraper.js"
  },
  "dependencies": {
    "diff": "^5.1.0",
    "dotenv": "^16.0.0",
    "formdata-node": "^6.0.3",
    "openai": "^5.9.0",
    "puppeteer": "^22.8.2",
    "sanitize-html": "^2.8.1"
  }
}
</file>

<file path="scraper/scraper.js">
import fs from 'fs/promises';
import path from 'path';
import puppeteer from 'puppeteer';
import sanitizeHtml from 'sanitize-html';
import { diffLines } from 'diff';
import OpenAI from 'openai';
import dotenv from 'dotenv';

const scriptDirForEnv = path.dirname(import.meta.url.substring(7));
dotenv.config({ path: path.resolve(scriptDirForEnv, '.env') });

const xai = new OpenAI({
  apiKey: process.env.XAI_API_KEY,
  baseURL: 'https://api.x.ai/v1'
});

const FAILURES_LOG = 'scraper/failures.log';
const AI_RETRIES = 3;

async function alertAdmin(details) {
  const webhookUrl = process.env.DISCORD_WEBHOOK_URL;
  const message = `
**Admin Alert**
**Service:** ${details.service}
**Document:** ${details.docType}
---
**Raw AI Response:**
\`\`\`
${details.rawResponse}
\`\`\`
  `;

  if (webhookUrl) {
    try {
      await fetch(webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: message }),
      });
      console.log(`Admin alert sent for ${details.service} ${details.docType}`);
    } catch (error) {
      console.error('Failed to send Discord alert:', error.message);
      const logMessage = `${new Date().toISOString()} - DISCORD_ALERT_FAILED: ${JSON.stringify(details)}\n`;
      await fs.appendFile(FAILURES_LOG, logMessage);
    }
  } else {
    console.warn(`Admin alert triggered for ${details.service} ${details.docType}, but no DISCORD_WEBHOOK_URL is set. Logging to failures.log.`);
    const logMessage = `${new Date().toISOString()} - ADMIN_ALERT: ${JSON.stringify(details)}\n`;
    await fs.appendFile(FAILURES_LOG, logMessage);
  }
}

// Helper function to split text into sentences
function splitIntoSentences(text) {
  // Remove HTML tags and normalize whitespace
  const cleanText = text.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
  // Split on sentence endings followed by whitespace
  return cleanText.split(/(?<=[.?!])\s+/).filter(sentence => sentence.trim().length > 0);
}

// Helper function to parse HTML into sections with headings
function parseIntoSections(html) {
  const sections = [];
  const lines = html.split('\n');
  let currentSection = null;
  let currentContent = [];
  
  for (const line of lines) {
    // Check for heading tags
    const headingMatch = line.match(/<h([1-6])[^>]*>(.*?)<\/h[1-6]>/i);
    if (headingMatch) {
      // Save previous section if exists
      if (currentSection) {
        sections.push({
          title: currentSection.title,
          content: currentContent.join('\n').trim(),
          level: currentSection.level
        });
      }
      
      // Start new section
      currentSection = {
        title: headingMatch[2].replace(/<[^>]*>/g, '').trim(),
        level: parseInt(headingMatch[1])
      };
      currentContent = [];
    } else if (currentSection) {
      currentContent.push(line);
    }
  }
  
  // Add the last section
  if (currentSection) {
    sections.push({
      title: currentSection.title,
      content: currentContent.join('\n').trim(),
      level: currentSection.level
    });
  }
  
  return sections;
}

// Helper function to find which section contains a given sentence
function findSectionForSentence(sentence, sections) {
  for (const section of sections) {
    if (section.content.includes(sentence)) {
      return section;
    }
  }
  return null;
}

// Helper function to create contextual diff with surrounding content
function createContextualDiff(oldText, newText) {
  const oldSentences = splitIntoSentences(oldText);
  const newSentences = splitIntoSentences(newText);
  const newSections = parseIntoSections(newText);
  
  const result = [];
  let i = 0, j = 0;
  
  while (i < oldSentences.length || j < newSentences.length) {
    if (i < oldSentences.length && j < newSentences.length && oldSentences[i] === newSentences[j]) {
      // Sentences match, keep unchanged
      result.push({ type: 'unchanged', value: oldSentences[i] });
      i++;
      j++;
    } else if (j < newSentences.length && (i >= oldSentences.length || !oldSentences.includes(newSentences[j]))) {
      // New sentence added
      const section = findSectionForSentence(newSentences[j], newSections);
      result.push({ 
        type: 'added', 
        value: newSentences[j],
        context: section ? section.title : null
      });
      j++;
    } else if (i < oldSentences.length && (j >= newSentences.length || !newSentences.includes(oldSentences[i]))) {
      // Old sentence removed
      result.push({ type: 'removed', value: oldSentences[i] });
      i++;
    } else {
      // Handle case where sentences are similar but not identical
      const section = findSectionForSentence(newSentences[j], newSections);
      result.push({ type: 'removed', value: oldSentences[i] });
      result.push({ 
        type: 'added', 
        value: newSentences[j],
        context: section ? section.title : null
      });
      i++;
      j++;
    }
  }
  
  return result;
}

// Helper function to create sentence-based diff (legacy, for backward compatibility)
function diffSentences(oldText, newText) {
  const oldSentences = splitIntoSentences(oldText);
  const newSentences = splitIntoSentences(newText);
  
  const result = [];
  let i = 0, j = 0;
  
  while (i < oldSentences.length || j < newSentences.length) {
    if (i < oldSentences.length && j < newSentences.length && oldSentences[i] === newSentences[j]) {
      // Sentences match, keep unchanged
      result.push({ type: 'unchanged', value: oldSentences[i] });
      i++;
      j++;
    } else if (j < newSentences.length && (i >= oldSentences.length || !oldSentences.includes(newSentences[j]))) {
      // New sentence added
      result.push({ type: 'added', value: newSentences[j] });
      j++;
    } else if (i < oldSentences.length && (j >= newSentences.length || !newSentences.includes(oldSentences[i]))) {
      // Old sentence removed
      result.push({ type: 'removed', value: oldSentences[i] });
      i++;
    } else {
      // Handle case where sentences are similar but not identical
      result.push({ type: 'removed', value: oldSentences[i] });
      result.push({ type: 'added', value: newSentences[j] });
      i++;
      j++;
    }
  }
  
  return result;
}

function getRandomDelay() {
  return Math.floor(Math.random() * 6000) + 2000;
}

async function scrapeDocument(page, cfg, docType, docSlug, url, selector, systemPrompt) {
  try {
    console.log(`Scraping ${cfg.service} ${docType}...`);
    
    try {
      await page.goto(url, { waitUntil: 'networkidle0', timeout: 30000 });
    } catch (error) {
      console.warn(`Failed to navigate to ${url} for ${cfg.service} ${docType}:`, error.message);
      return;
    }

    let raw;
    try {
      raw = await page.$eval(selector, el => el.innerHTML);
    } catch (error) {
      console.warn(`Selector "${selector}" not found for ${cfg.service} ${docType}:`, error.message);
      return;
    }

    const clean = sanitizeHtml(raw, {
      allowedTags: [
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'a', 'b', 'i', 'strong', 'em', 'ul', 'ol', 'li', 'blockquote', 'pre', 'code', 'br', 'hr', 'table', 'thead', 'tbody', 'tr', 'th', 'td'
      ],
      allowedAttributes: {
        'a': ['href', 'target', 'rel']
      }
    });

    const storage = path.join('scraper/storage', cfg.service, docSlug);
    await fs.mkdir(storage, { recursive: true });
    const prevFile = path.join(storage, 'prev.html');
    let prev = '';
    let isFirstRun = false;
    try {
      prev = await fs.readFile(prevFile, 'utf-8');
    } catch {
      isFirstRun = true;
    }

    if (prev === clean) {
      console.log(`No changes detected for ${cfg.service} ${docType}`);
      return;
    }

    // On the first run, just save the file and exit
    if (isFirstRun) {
      await fs.writeFile(prevFile, clean);
      console.log(`Initial content saved for ${cfg.service} ${docType}. No diff generated on first run.`);
      return;
    }

    await fs.writeFile(prevFile, clean);
    
    // Use contextual diffing to provide better context to AI
    const contextualDiff = createContextualDiff(prev, clean);
    
    // Build contextual prompt with section information
    const contextualChanges = contextualDiff
      .filter(p => p.type === 'added' || p.type === 'removed')
      .map(p => {
        const prefix = p.type === 'added' ? '+' : '-';
        const context = p.context ? ` [Section: ${p.context}]` : '';
        return `${prefix}${p.value}${context}`;
      });
    
    const diffText = contextualChanges.join('\n');
    
    // Create simple diff for HTML display (without context)
    const simpleDiff = contextualDiff.map(p => 
      (p.type === 'added' ? '+' : p.type === 'removed' ? '-' : '') + p.value
    ).join('\n');

    const diffHtml = contextualDiff.map(p => {
      const esc = p.value
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;');
      if (p.type === 'added') return `<div class="added">${esc}</div>`;
      if (p.type === 'removed') return `<div class="removed">${esc}</div>`;
      return `<div>${esc}</div>`;
    }).join('');

    const prompt = `Summarize these ${docType} changes as a Markdown bullet list. Each change includes the section context where it occurred:\n\n${diffText}`;
    
    let completion;
    let lastError = null;

    for (let i = 0; i < AI_RETRIES; i++) {
      try {
        completion = await xai.chat.completions.create({
          model: 'grok-3-mini',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: prompt }
          ],
          reasoning_effort: 'high'
        });
        lastError = null; // Clear error on success
        break; // Exit loop on success
      } catch (error) {
        lastError = error;
        console.warn(`AI completion failed for ${cfg.service} ${docType} (attempt ${i + 1}/${AI_RETRIES}):`, error.message);
        if (i < AI_RETRIES - 1) {
          await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s before retry
        }
      }
    }

    if (lastError) {
      const logMessage = `${new Date().toISOString()} - SERVICE: ${cfg.service}, TYPE: ${docType}, ERROR: ${lastError.message}\n`;
      await fs.appendFile(FAILURES_LOG, logMessage);
      
      console.warn(`AI summary failed for ${cfg.service} ${docType} after ${AI_RETRIES} attempts. Logged to ${FAILURES_LOG}.`);
      const outDir = path.join('web/static/data', cfg.service.toLowerCase(), docSlug);
      await fs.mkdir(outDir, { recursive: true });
      const changesFile = path.join(outDir, 'changes.json');
      
      let data = { schemaVersion: 2, changes: [] };
      try {
        const fileContent = await fs.readFile(changesFile, 'utf-8');
        const existingData = JSON.parse(fileContent);
        if (Array.isArray(existingData)) {
          data.changes = existingData;
        } else {
          data = existingData;
        }
      } catch {}
      
      data.changes.unshift({
        timestamp: new Date().toISOString(),
        type: docType,
        summary: ['<p>Changes detected but AI summary failed</p>'],
        diffHtml
      });
      await fs.writeFile(changesFile, JSON.stringify(data, null, 2));
      return; // End execution for this document
    }
    
    const aiResponse = completion.choices[0].message.content;

    if (aiResponse.includes('alert_admin()')) {
      await alertAdmin({
        service: cfg.service,
        docType: docType,
        rawResponse: aiResponse
      });
    }

    const summaryLines = aiResponse
      .replace(/alert_admin\(\)/g, '') // Remove the function call from the output
      .trim()
      .split(/\r?\n/)
      .filter(Boolean)
      .map(l => `<p>${l}</p>`);

    const outDir = path.join('web/static/data', cfg.service.toLowerCase(), docSlug);
    await fs.mkdir(outDir, { recursive: true });
    const changesFile = path.join(outDir, 'changes.json');

    let data = { schemaVersion: 2, changes: [] };
    try {
      const fileContent = await fs.readFile(changesFile, 'utf-8');
      const existingData = JSON.parse(fileContent);
      if (Array.isArray(existingData)) {
        data.changes = existingData; // Convert old format
      } else if (existingData && typeof existingData === 'object') {
        data = existingData;
      }
    } catch {}

    data.changes.unshift({
      timestamp: new Date().toISOString(),
      type: docType,
      summary: summaryLines,
      diffHtml
    });
    await fs.writeFile(changesFile, JSON.stringify(data, null, 2));
    
    console.log(`Changes detected and processed for ${cfg.service} ${docType}`);

  } catch (error) {
    console.error(`Unexpected error processing ${cfg.service} ${docType}:`, error.message);
  }
}

async function scrapeService(page, cfg, systemPrompt) {
  if (!cfg.documents) return;

  const docTypes = Object.keys(cfg.documents);
  for (let i = 0; i < docTypes.length; i++) {
    const docType = docTypes[i];
    const docConfig = cfg.documents[docType];
    if (docConfig.url && docConfig.selector) {
      const docSlug = docType.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
      await scrapeDocument(page, cfg, docType, docSlug, docConfig.url, docConfig.selector, systemPrompt);
    }
    
    if (i < docTypes.length - 1) {
      const delay = getRandomDelay();
      console.log(`Waiting ${delay / 1000}s before next scrape...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

async function main() {
  const scriptDir = path.dirname(import.meta.url.substring(7));
  const systemPromptPath = path.resolve(scriptDir, 'system_prompt.txt');
  const systemPrompt = await fs.readFile(systemPromptPath, 'utf-8');
  
  // Ensure the web data directory exists
  await fs.mkdir('web/static/data', { recursive: true });
  
  let browser;
  try {
    console.log('Launching browser...');
    browser = await puppeteer.launch({ args: ['--no-sandbox'] });
    
    const cfgDir = path.resolve(scriptDir, '../service-config');
    const files = await fs.readdir(cfgDir);
    
    for (const f of files) {
      if (!f.endsWith('.json')) continue;
      
      const cfg = JSON.parse(await fs.readFile(path.join(cfgDir, f), 'utf-8'));
      
      const page = await browser.newPage();
      try {
        await scrapeService(page, cfg, systemPrompt);
      } finally {
        await page.close();
      }
    }
  } catch (error) {
    console.error('Error in main:', error);
  } finally {
    if (browser) {
      console.log('Closing browser...');
      await browser.close();
    }
  }
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
</file>

<file path="scraper/system_prompt.txt">
You are a legal-change assistant. When you receive HTML diffs of Terms of Service or Privacy Policy changes, summarize them as a Markdown bullet list. For each change, follow these rules:

1. Start each bullet with one or more type tags in square brackets, with no spaces inside the brackets.
   - If there's a single applicable category, use `[Category]`.
   - If multiple apply, list them comma-separated within the same brackets, e.g. `[Data Sharing, Consent Requirement]`.
2. After the closing bracket(s), put a space, then a concise description of the change in plain English.
3. Use exactly these categories (case-sensitive):
   - New Obligation
   - Privacy Impact
   - Data Sharing
   - Tracking Change
   - Consent Requirement
   - Permission Grant
   - Security Update
   - Payment Terms
   - Termination Clause
   - Retention Policy
   - Third-Party Integration
   - Age Restriction
   - Service Modification
   - Typo Fix
   - Formatting Change
   - Clarification
4. If a change does not clearly match any category, use `[Clarification]`.
5. Do not include any other text outside the bullet list. Example output:
   - [Data Sharing] Third-party analytics provider X added to Section 4.
   - [Typo Fix] Corrected "privact" to "privacy" in subsection 2.
6. If you detect any of the following, call `alert_admin()` instead of—or in addition to—your summary:
   - A major clause addition or removal with broad legal or privacy impact
   - Malformed, empty, or unexpectedly truncated diff content
   - Uncertainty about the real-world implications or nuanced legal context
   - Any change exceeding 200 words or containing unusual formatting
</file>

<file path="service-config/google.json">
{
  "service": "Google",
  "documents": {
    "Terms of Service": {
      "url": "https://policies.google.com/terms",
      "selector": "#main-content"
    },
    "Privacy Policy": {
      "url": "https://policies.google.com/privacy",
      "selector": "#main-content"
    }
  },
  "aliases": ["Google", "Alphabet"]
}
</file>

<file path="service-config/sidebysearch.json">
{
  "service": "SideBySearch",
  "documents": {
    "Privacy Policy": {
      "url": "https://sidebysearch.org/privacy",
      "selector": "main"
    }
  }
}
</file>

<file path="web/src/lib/services.js">
export default ['google', 'sidebysearch'];
</file>

<file path="web/src/routes/api/services/[service]/+server.js">
import fs from 'fs/promises';
import path from 'path';

export async function GET({ params }) {
  try {
    const serviceName = params.service.toLowerCase();
    
    // Construct the path to the config file from the project root.
    const configPath = path.resolve('service-config', `${serviceName}.json`);
    
    const fileContent = await fs.readFile(configPath, 'utf-8');
    const config = JSON.parse(fileContent);
    
    const documents = Object.keys(config.documents || {});
    
    return new Response(JSON.stringify({ documents }), {
      headers: { 'Content-Type': 'application/json' },
      status: 200
    });

  } catch (error) {
    // If the file doesn't exist or there's an error, return a 404.
    return new Response(JSON.stringify({ error: 'Service not found' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
</file>

<file path="web/src/routes/disclaimer/+page.svelte">
<h1>Disclaimer</h1>

<p><strong>No Affiliation:</strong> This website is an independent project and is not affiliated with, endorsed by, or in any way officially connected with any of the companies whose terms of service or privacy policies are displayed here. All company names, logos, and trademarks are the property of their respective owners.</p>

<p><strong>For Informational Purposes Only:</strong> The content provided on this website is for informational purposes only. It is automatically scraped from public sources and is presented without any alteration or manual review. The goal is to provide a convenient way to track changes to these legal documents over time.</p>

<p><strong>No Legal Advice:</strong> The information on this site does not constitute, and should not be relied upon as, legal advice. We make no representations or warranties of any kind, express or implied, about the completeness, accuracy, reliability, suitability, or availability of the information contained on the website.</p>

<p><strong>Verify Information:</strong> We strongly encourage all users to review the official terms of service and privacy policies directly on the respective companies' websites before making any decisions based on the information presented here. Your legal rights and obligations are determined by the original documents.</p>

<p><strong>Limitation of Liability:</strong> In no event will we be liable for any loss or damage including without limitation, indirect or consequential loss or damage, or any loss or damage whatsoever arising from loss of data or profits arising out of, or in connection with, the use of this website.</p>

<style>
  h1 {
    margin-bottom: 2rem;
  }
  p {
    margin-bottom: 1rem;
    line-height: 1.6;
    max-width: 80ch;
  }
  p strong {
    color: var(--text-primary);
    font-weight: 700;
  }
</style>
</file>

<file path="web/src/routes/services/[service]/+page.js">
export async function load({ params, fetch }) {
  try {
    const svc = params.service.toLowerCase();

    // 1. Fetch the list of documents for the service
    const docsRes = await fetch(`/api/services/${svc}`);
    if (!docsRes.ok) {
      // Return a default structure if the service config doesn't exist.
      return { service: params.service, documents: {}, activeTab: null };
    }
    const { documents: docNames } = await docsRes.json();

    // 2. Create fetch promises for each document's changes
    const slugify = (text) => text.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
    const promises = docNames.map(docName =>
      fetch(`/data/${svc}/${slugify(docName)}/changes.json`)
    );
    const results = await Promise.allSettled(promises);

    // 3. Process results into a structured object
    const documents = {};
    for (let i = 0; i < docNames.length; i++) {
      const docName = docNames[i];
      const res = results[i];
      let changes = [];
      if (res.status === 'fulfilled' && res.value.ok) {
        const data = await res.value.json();
        // Support both old and new schema versions
        changes = data.changes || (Array.isArray(data) ? data : []);
      }
      documents[docName] = { changes };
    }

    // 4. Return props for the page
    return {
      service: params.service,
      documents,
      // Set the first available document as the active one
      activeTab: docNames.length > 0 ? docNames[0] : null
    };

  } catch (error) {
    console.error("Failed to load service changes:", error);
    // Return default props on error to prevent a crash
    return {
      service: params.service,
      documents: {},
      activeTab: null
    };
  }
}
</file>

<file path="web/src/routes/services/[service]/+page.svelte">
<script>
  export let data;

  let activeTab = data.activeTab;
  
  function setActiveTab(tab) {
    activeTab = tab;
  }
</script>

<h1><a href="/">{data.service}</a> Legal Document Changes</h1>

{#if data.documents && Object.keys(data.documents).length > 0}
  <div class="tabs">
    {#each Object.keys(data.documents) as docName}
      <button
        class:active={activeTab === docName}
        on:click={() => setActiveTab(docName)}
        disabled={data.documents[docName].changes.length === 0}
      >
        {docName} ({data.documents[docName].changes.length})
      </button>
    {/each}
  </div>

  {#if activeTab && data.documents[activeTab]}
    {@const currentDoc = data.documents[activeTab]}
    <div class="content">
      {#if currentDoc.changes.length === 0}
        <p>No {activeTab} changes detected yet.</p>
      {:else}
        {#each currentDoc.changes as change}
          <section>
            <h2>{new Date(change.timestamp).toLocaleString()}</h2>
            <div class="summary">
              {@html change.summary.join('')}
            </div>
            <details>
              <summary>View full diff</summary>
              <div class="diff">
                {@html change.diffHtml}
              </div>
            </details>
          </section>
        {/each}
      {/if}
    </div>
  {/if}
{:else}
  <p>No documents are configured for this service yet.</p>
{/if}

<style>
  h1 a {
    text-decoration: none;
    color: inherit;
  }
  .tabs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 2rem;
    border-bottom: 1px solid var(--border);
  }
  
  .tabs button {
    padding: 0.75rem 1.25rem;
    border: none;
    background: transparent;
    cursor: pointer;
    border-radius: 6px 6px 0 0;
    font-size: 1rem;
    color: var(--text-secondary);
    position: relative;
    top: 1px;
    transition: background-color 0.2s ease, color 0.2s ease;
  }

  .tabs button:disabled {
    color: var(--text-secondary);
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .tabs button.active {
    background: var(--background);
    color: var(--primary);
    border-bottom: 2px solid var(--primary);
  }

  .tabs button:not(.active):not(:disabled):hover {
    background-color: var(--surface);
    color: var(--text-primary);
  }
  
  .content {
    margin-top: 1rem;
  }
  
  section {
    margin-bottom: 2rem;
    padding: 1.5rem;
    border: 1px solid var(--border);
    border-radius: 8px;
    background-color: var(--surface);
  }

  section h2 {
    font-size: 1rem;
    font-weight: normal;
    color: var(--text-secondary);
    margin-top: 0;
  }
  
  .summary {
    margin: 1rem 0;
  }

  .summary :global(p) {
    margin: 0.5rem 0;
  }
  
  details {
    margin-top: 1.5rem;
  }

  details summary {
    cursor: pointer;
    font-weight: bold;
    color: var(--text-secondary);
  }

  details summary:hover {
    color: var(--primary);
  }
  
  .diff {
    margin-top: 1rem;
    padding: 1rem;
    background: var(--background);
    border-radius: 4px;
    font-family: 'Roboto Mono', monospace;
    white-space: pre-wrap;
    font-size: 0.9em;
    border: 1px solid var(--border);
  }
</style>
</file>

<file path="web/src/routes/+layout.css">
:root {
  --background: #1a1d21;
  --surface: #2a2d31;
  --primary: #4f89f2;
  --on-primary: #ffffff;
  --text-primary: #e1e1e6;
  --text-secondary: #c4c4cc;
  --border: #3a3d41;
  --added-bg: rgba(77, 182, 172, 0.1);
  --removed-bg: rgba(244, 67, 54, 0.1);
  --added-color: #4db6ac;
  --removed-color: #f44336;
}

.added {
  background-color: var(--added-bg);
  color: var(--added-color);
}
.removed {
  background-color: var(--removed-bg);
  color: var(--removed-color);
}

body {
  font-family: 'Inter', sans-serif;
  margin: 0;
  padding: 2rem;
  background-color: var(--background);
  color: var(--text-primary);
  line-height: 1.6;
}

nav {
  display: flex;
  gap: 1.5rem;
  padding-bottom: 2rem;
  border-bottom: 1px solid var(--border);
  margin-bottom: 2rem;
}

nav a {
  text-decoration: none;
  font-weight: bold;
  color: var(--text-secondary);
  transition: color 0.2s ease-in-out;
}

nav a:hover {
  color: var(--primary);
}

h1, h2, h3 {
  color: var(--text-primary);
  font-weight: 700;
}

a {
  color: var(--primary);
}
</file>

<file path="web/src/routes/+layout.svelte">
<script>
  import './+layout.css';
</script>

<nav>
  <a href="/">Home</a>
  <a href="/disclaimer" style="margin-left: 1rem;">Disclaimer</a>
</nav>

<slot />
</file>

<file path="web/src/routes/+page.svelte">
<script>
  import services from '$lib/services.js';
</script>

<h1>Terms of Service Tracker</h1>
<ul>
  {#each services as svc}
    <li><a href={`/services/${svc}`}>{svc}</a></li>
  {/each}
</ul>
</file>

<file path="web/src/app.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.png" />
    <meta name="viewport" content="width=device-width" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    %sveltekit.head%
  </head>
  <body>
    <div style="display: contents">
      %sveltekit.body%
    </div>
  </body>
</html>
</file>

<file path="web/src/hooks.server.js">
import { dev } from '$app/environment';

export const handle = async ({ event, resolve }) => {
  const response = await resolve(event);

  // Apply security headers only to top-level page responses,
  // not to sub-requests made by `load` functions.
  if (!event.isSubRequest) {
    const csp = [
      "default-src 'self'",
      // Vite's HMR client requires 'unsafe-inline' for scripts in dev
      `script-src 'self' ${dev ? "'unsafe-inline'" : ''}`,
      // Google Fonts requires fonts.googleapis.com for styles.
      // SvelteKit's dev server injects styles inline, so we need 'unsafe-inline' in dev.
      `style-src 'self' https://fonts.googleapis.com ${dev ? "'unsafe-inline'" : ''}`,
      // Allow font files from Google's static domain
      "font-src 'self' https://fonts.gstatic.com",
      // Allow websocket connection for Vite's HMR
      `connect-src 'self' ${dev ? 'ws:' : ''}`,
    ]
      .join('; ')
      .trim();

    response.headers.set('Content-Security-Policy', csp);
    response.headers.set(
      'Strict-Transport-Security',
      'max-age=31536000; includeSubDomains'
    );
  }

  return response;
};
</file>

<file path="web/package.json">
{
  "name": "tos-diff-web",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite dev",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@sveltejs/kit": "^2.22.5",
    "svelte": "^5.0.0"
  },
  "devDependencies": {
    "@sveltejs/adapter-static": "^3.0.8",
    "@types/estree": "^1.0.8",
    "svelte-preprocess": "^6.0.3"
  },
  "overrides": {
    "cookie": "0.7.1"
  }
}
</file>

<file path="web/svelte.config.js">
import adapter from '@sveltejs/adapter-static';
import preprocess from 'svelte-preprocess';

export default {
  preprocess: preprocess(),
  kit: {
    // tell adapter-static to emit a SPA fallback "200.html"
    // and not error out on dynamic routes
    adapter: adapter({
      pages: 'build',
      assets: 'build',
      fallback: '200.html',
      strict: false
    })
  }
};
</file>

<file path="web/tsconfig.json">
{
  "extends": "./.svelte-kit/tsconfig.json",
  "compilerOptions": {
    "strict": true,
    "skipLibCheck": true,
    "types": []
  }
}
</file>

<file path="web/vite.config.js">
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [sveltekit()]
});
</file>

<file path=".github/workflows/scraper.yml">
name: Automated Document Scraper

on:
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch: # Allow manual triggering

jobs:
  scrape:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: Install dependencies
      run: |
        cd scraper
        npm install
        
    - name: Run scraper
      env:
        # These secrets are configured in GitHub repository settings
        XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        node scraper/scraper.js
        
    - name: Check for changes
      id: check_changes
      run: |
        if [ -n "$(git status --porcelain)" ]; then
          echo "has_changes=true" >> $GITHUB_OUTPUT
        else
          echo "has_changes=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Commit and push changes
      if: steps.check_changes.outputs.has_changes == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        git commit -m "Auto-update: Document changes detected $(date)"
        git push
</file>

</files>
